import {
  DateField,
  DatePicker,
  DatePickerToolbar,
  DayCalendarSkeleton,
  DesktopDatePicker,
  DesktopTimePicker,
  MobileDatePicker,
  MobileTimePicker,
  StaticDatePicker,
  StaticDateTimePicker,
  StaticTimePicker,
  TimeField,
  TimePicker,
  TimePickerToolbar,
  datePickerToolbarClasses,
  dayCalendarSkeletonClasses,
  getDayCalendarSkeletonUtilityClass,
  timePickerToolbarClasses,
  useDateField,
  useTimeField
} from "./chunk-GQ4F5FPK.js";
import {
  ArrowDropDownIcon,
  ArrowLeftIcon,
  ArrowRightIcon,
  CalendarIcon,
  ClearIcon,
  ClockIcon,
  DAY_MARGIN,
  DEFAULT_DESKTOP_MODE_MEDIA_QUERY,
  DIALOG_WIDTH,
  DateCalendar,
  DateRangeIcon,
  DateTimeField,
  DateTimePicker,
  DateTimePickerTabs,
  DateTimePickerToolbar,
  DayCalendar,
  DesktopDateTimePicker,
  DesktopDateTimePickerLayout,
  DigitalClock,
  LocalizationProvider,
  MobileDateTimePicker,
  MonthCalendar,
  MuiPickersAdapterContext,
  MultiSectionDigitalClock,
  PickersActionBar,
  PickersArrowSwitcher,
  PickersCalendarHeader,
  PickersDay,
  PickersFilledInput,
  PickersInput,
  PickersInputBase,
  PickersLayout,
  PickersLayoutContentWrapper,
  PickersLayoutRoot,
  PickersModalDialog,
  PickersOutlinedInput,
  PickersPopper,
  PickersSectionList,
  PickersSectionListRoot,
  PickersSectionListSection,
  PickersSectionListSectionContent,
  PickersSectionListSectionSeparator,
  PickersShortcuts,
  PickersTextField,
  PickersToolbar,
  PickersToolbarButton,
  TimeClock,
  TimeIcon,
  VIEW_HEIGHT,
  YearCalendar,
  applyDefaultDate,
  applyDefaultViewProps,
  areDatesEqual,
  clockClasses,
  clockNumberClasses,
  clockPointerClasses,
  convertFieldResponseIntoMuiTextFieldProps,
  createDateStrForV6InputFromSections,
  createDateStrForV7HiddenInputFromSections,
  dateCalendarClasses,
  dateTimePickerTabsClasses,
  dateTimePickerToolbarClasses,
  dayCalendarClasses,
  digitalClockClasses,
  executeInTheNextEventLoopTick,
  extractValidationProps,
  getActiveElement,
  getDateCalendarUtilityClass,
  getDefaultReferenceDate,
  getDigitalClockUtilityClass,
  getMonthCalendarUtilityClass,
  getMultiSectionDigitalClockUtilityClass,
  getPickersDayUtilityClass,
  getPickersFilledInputUtilityClass,
  getPickersInputBaseUtilityClass,
  getPickersInputUtilityClass,
  getPickersOutlinedInputUtilityClass,
  getPickersSectionListUtilityClass,
  getPickersTextFieldUtilityClass,
  getTimeClockUtilityClass,
  getTodayDate,
  getYearCalendarUtilityClass,
  isDatePickerView,
  isInternalTimeView,
  mergeDateAndTime,
  monthCalendarClasses,
  multiSectionDigitalClockClasses,
  multiSectionDigitalClockSectionClasses,
  onSpaceOrEnter,
  pickersCalendarHeaderClasses,
  pickersDayClasses,
  pickersFadeTransitionGroupClasses,
  pickersFilledInputClasses,
  pickersInputBaseClasses,
  pickersInputClasses,
  pickersLayoutClasses,
  pickersMonthClasses,
  pickersOutlinedInputClasses,
  pickersSectionListClasses,
  pickersSlideTransitionClasses,
  pickersTextFieldClasses,
  pickersYearClasses,
  renderDateViewCalendar,
  renderDigitalClockTimeView,
  renderMultiSectionDigitalClockTimeView,
  renderTimeViewClock,
  replaceInvalidDateByNull,
  resolveDateTimeFormat,
  resolveTimeViewsResponse,
  splitFieldInternalAndForwardedProps,
  timeClockClasses,
  useCalendarState,
  useClearableField,
  useControlledValueWithTimezone,
  useDateTimeField,
  useDefaultDates,
  useDefaultReduceAnimations,
  useDefaultizedDateField,
  useDefaultizedDateTimeField,
  useDefaultizedTimeField,
  useField,
  useLocalizationContext,
  useNextMonthDisabled,
  useNow,
  usePicker,
  usePickerLayout_default,
  usePickersTranslations,
  usePreviousMonthDisabled,
  useUtils,
  useValidation,
  useViews,
  validateDate,
  validateDateTime,
  validateTime,
  yearCalendarClasses
} from "./chunk-TDD6PXMO.js";
import {
  warnOnce
} from "./chunk-676UNTYT.js";
import {
  Stack_default
} from "./chunk-PXHUHZAV.js";
import "./chunk-JWGNUYIH.js";
import {
  Button_default,
  IconButton_default,
  TextField_default
} from "./chunk-CQ3KKKXP.js";
import "./chunk-J4HOOEOT.js";
import "./chunk-TGA5XIYL.js";
import {
  Divider_default,
  Typography_default
} from "./chunk-MX2IH6ZL.js";
import "./chunk-U3R3OX25.js";
import "./chunk-JDSHOWCZ.js";
import "./chunk-FWENSTUV.js";
import "./chunk-7WPZNNV2.js";
import "./chunk-3IHV7RO6.js";
import {
  useThemeProps
} from "./chunk-IHVYYSWH.js";
import "./chunk-ZIIF3WQM.js";
import {
  alpha
} from "./chunk-OH67BUKE.js";
import "./chunk-EXOAFPCI.js";
import "./chunk-YQBMKNN2.js";
import {
  useMediaQuery
} from "./chunk-ZIKJVT6O.js";
import "./chunk-AGAAIYYJ.js";
import "./chunk-CKIWQ7T3.js";
import "./chunk-ALTQJTQO.js";
import "./chunk-HH5HEH3O.js";
import {
  styled_default
} from "./chunk-MM6WSJYD.js";
import {
  composeClasses,
  generateUtilityClass,
  generateUtilityClasses,
  init_composeClasses,
  init_esm,
  init_generateUtilityClass,
  init_generateUtilityClasses,
  init_resolveComponentProps,
  init_useControlled,
  init_useEventCallback,
  init_useForkRef,
  init_useId,
  init_useSlotProps,
  ponyfillGlobal_default,
  refType_default,
  resolveComponentProps_default,
  useControlled,
  useEventCallback_default,
  useForkRef,
  useId,
  useSlotProps_default
} from "./chunk-UVT7GP3T.js";
import {
  clsx,
  clsx_default,
  init_clsx
} from "./chunk-KGFDDYBK.js";
import "./chunk-CNDJGJ66.js";
import {
  _objectWithoutPropertiesLoose,
  init_objectWithoutPropertiesLoose,
  require_prop_types
} from "./chunk-7WDGFAHI.js";
import {
  _extends,
  init_extends
} from "./chunk-Q7CPF5VB.js";
import {
  require_jsx_runtime
} from "./chunk-OT5EQO2H.js";
import {
  require_react
} from "./chunk-OU5AQDZK.js";
import {
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/@mui/x-license/encoding/md5.js
var k = [];
var i = 0;
for (; i < 64; ) {
  k[i] = 0 | Math.sin(++i % Math.PI) * 4294967296;
}
function md5(s) {
  const words = [];
  let b, c, d, j = unescape(encodeURI(s)) + "", a = j.length;
  const h = [b = 1732584193, c = 4023233417, ~b, ~c];
  s = --a / 4 + 2 | 15;
  words[--s] = a * 8;
  for (; ~a; ) {
    words[a >> 2] |= j.charCodeAt(a) << 8 * a--;
  }
  for (i = j = 0; i < s; i += 16) {
    a = h;
    for (; j < 64; a = [d = a[3], b + ((d = a[0] + [b & c | ~b & d, d & b | ~d & c, b ^ c ^ d, c ^ (b | ~d)][a = j >> 4] + k[j] + ~~words[i | [j, 5 * j + 1, 3 * j + 5, 7 * j][a] & 15]) << (a = [7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21][4 * a + j++ % 4]) | d >>> -a), b, c]) {
      b = a[1] | 0;
      c = a[2];
    }
    for (j = 4; j; ) h[--j] += a[j];
  }
  for (s = ""; j < 32; ) {
    s += (h[j >> 3] >> (1 ^ j++) * 4 & 15).toString(16);
  }
  return s;
}

// node_modules/@mui/x-license/encoding/base64.js
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var base64Decode = (input) => {
  let output = "";
  let chr1, chr2, chr3;
  let enc1, enc2, enc3, enc4;
  let i2 = 0;
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  while (i2 < input.length) {
    enc1 = _keyStr.indexOf(input.charAt(i2++));
    enc2 = _keyStr.indexOf(input.charAt(i2++));
    enc3 = _keyStr.indexOf(input.charAt(i2++));
    enc4 = _keyStr.indexOf(input.charAt(i2++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    output = output + String.fromCharCode(chr1);
    if (enc3 != 64) {
      output = output + String.fromCharCode(chr2);
    }
    if (enc4 != 64) {
      output = output + String.fromCharCode(chr3);
    }
  }
  return output;
};

// node_modules/@mui/x-license/utils/licenseScope.js
var LICENSE_SCOPES = ["pro", "premium"];

// node_modules/@mui/x-license/utils/licensingModel.js
var LICENSING_MODELS = [
  /**
   * A license is outdated if the current version of the software was released after the expiry date of the license.
   * But the license can be used indefinitely with an older version of the software.
   */
  "perpetual",
  /**
   * On development, a license is outdated if the expiry date has been reached
   * On production, a license is outdated if the current version of the software was released after the expiry date of the license (see "perpetual")
   */
  "annual",
  /**
   * TODO 2025 remove, legacy name of annual.
   */
  "subscription"
];

// node_modules/@mui/x-license/utils/licenseErrorMessageUtils.js
function showError(message) {
  console.error(["*************************************************************", "", ...message, "", "*************************************************************"].join("\n"));
}
function showInvalidLicenseKeyError() {
  showError(["MUI X: Invalid license key.", "", "Your MUI X license key format isn't valid. It could be because the license key is missing a character or has a typo.", "", "To solve the issue, you need to double check that `setLicenseKey()` is called with the right argument", "Please check the license key installation https://mui.com/r/x-license-key-installation."]);
}
function showLicenseKeyPlanMismatchError() {
  showError(["MUI X: License key plan mismatch.", "", "Your use of MUI X is not compatible with the plan of your license key. The feature you are trying to use is not included in the plan of your license key. This happens if you try to use `DataGridPremium` with a license key for the Pro plan.", "", "To solve the issue, you can upgrade your plan from Pro to Premium at https://mui.com/r/x-get-license?scope=premium.", "Of if you didn't intend to use Premium features, you can replace the import of `@mui/x-data-grid-premium` with `@mui/x-data-grid-pro`."]);
}
function showNotAvailableInInitialProPlanError() {
  showError(["MUI X: Component not included in your license.", "", "The component you are trying to use is not included in the Pro Plan you purchased.", "", "Your license is from an old version of the Pro Plan that is only compatible with the `@mui/x-data-grid-pro` and `@mui/x-date-pickers-pro` commercial packages.", "", "To start using another Pro package, please consider reaching to our sales team to upgrade your license or visit https://mui.com/r/x-get-license to get a new license key."]);
}
function showMissingLicenseKeyError({
  plan,
  packageName
}) {
  showError(["MUI X: Missing license key.", "", `The license key is missing. You might not be allowed to use \`${packageName}\` which is part of MUI X ${plan}.`, "", "To solve the issue, you can check the free trial conditions: https://mui.com/r/x-license-trial.", "If you are eligible no actions are required. If you are not eligible to the free trial, you need to purchase a license https://mui.com/r/x-get-license or stop using the software immediately."]);
}
function showExpiredPackageVersionError({
  packageName
}) {
  showError(["MUI X: Expired package version.", "", `You have installed a version of \`${packageName}\` that is outside of the maintenance plan of your license key. By default, commercial licenses provide access to new versions released during the first year after the purchase.`, "", "To solve the issue, you can renew your license https://mui.com/r/x-get-license or install an older version of the npm package that is compatible with your license key."]);
}
function showExpiredAnnualGraceLicenseKeyError({
  plan,
  licenseKey,
  expiryTimestamp
}) {
  showError(["MUI X: Expired license key.", "", `Your annual license key to use MUI X ${plan} in non-production environments has expired. If you are seeing this development console message, you might be close to breach the license terms by making direct or indirect changes to the frontend of an app that render a MUI X ${plan} component (more details in https://mui.com/r/x-license-annual).`, "", "To solve the problem you can either:", "", "- Renew your license https://mui.com/r/x-get-license and use the new key", `- Stop making changes to code depending directly or indirectly on MUI X ${plan}'s APIs`, "", "Note that your license is perpetual in production environments with any version released before your license term ends.", "", `- License key expiry timestamp: ${new Date(expiryTimestamp)}`, `- Installed license key: ${licenseKey}`, ""]);
}
function showExpiredAnnualLicenseKeyError({
  plan,
  licenseKey,
  expiryTimestamp
}) {
  throw new Error(["MUI X: Expired license key.", "", `Your annual license key to use MUI X ${plan} in non-production environments has expired. If you are seeing this development console message, you might be close to breach the license terms by making direct or indirect changes to the frontend of an app that render a MUI X ${plan} component (more details in https://mui.com/r/x-license-annual).`, "", "To solve the problem you can either:", "", "- Renew your license https://mui.com/r/x-get-license and use the new key", `- Stop making changes to code depending directly or indirectly on MUI X ${plan}'s APIs`, "", "Note that your license is perpetual in production environments with any version released before your license term ends.", "", `- License key expiry timestamp: ${new Date(expiryTimestamp)}`, `- Installed license key: ${licenseKey}`, ""].join("\n"));
}

// node_modules/@mui/x-license/utils/licenseInfo.js
init_esm();
ponyfillGlobal_default.__MUI_LICENSE_INFO__ = ponyfillGlobal_default.__MUI_LICENSE_INFO__ || {
  key: void 0
};
var LicenseInfo = class _LicenseInfo {
  static getLicenseInfo() {
    return ponyfillGlobal_default.__MUI_LICENSE_INFO__;
  }
  static getLicenseKey() {
    return _LicenseInfo.getLicenseInfo().key;
  }
  static setLicenseKey(key) {
    const licenseInfo = _LicenseInfo.getLicenseInfo();
    licenseInfo.key = key;
  }
};

// node_modules/@mui/x-license/utils/licenseStatus.js
var LICENSE_STATUS = function(LICENSE_STATUS2) {
  LICENSE_STATUS2["NotFound"] = "NotFound";
  LICENSE_STATUS2["Invalid"] = "Invalid";
  LICENSE_STATUS2["ExpiredAnnual"] = "ExpiredAnnual";
  LICENSE_STATUS2["ExpiredAnnualGrace"] = "ExpiredAnnualGrace";
  LICENSE_STATUS2["ExpiredVersion"] = "ExpiredVersion";
  LICENSE_STATUS2["Valid"] = "Valid";
  LICENSE_STATUS2["OutOfScope"] = "OutOfScope";
  LICENSE_STATUS2["NotAvailableInInitialProPlan"] = "NotAvailableInInitialProPlan";
  return LICENSE_STATUS2;
}({});

// node_modules/@mui/x-license/verifyLicense/verifyLicense.js
function isLicenseScopeSufficient(packageName, licenseScope) {
  let acceptedScopes;
  if (packageName.includes("-pro")) {
    acceptedScopes = ["pro", "premium"];
  } else if (packageName.includes("-premium")) {
    acceptedScopes = ["premium"];
  } else {
    acceptedScopes = [];
  }
  return acceptedScopes.includes(licenseScope);
}
var expiryReg = /^.*EXPIRY=([0-9]+),.*$/;
var PRO_PACKAGES_AVAILABLE_IN_INITIAL_PRO_PLAN = ["x-data-grid-pro", "x-date-pickers-pro"];
var decodeLicenseVersion1 = (license) => {
  let expiryTimestamp;
  try {
    expiryTimestamp = parseInt(license.match(expiryReg)[1], 10);
    if (!expiryTimestamp || Number.isNaN(expiryTimestamp)) {
      expiryTimestamp = null;
    }
  } catch (err) {
    expiryTimestamp = null;
  }
  return {
    scope: "pro",
    licensingModel: "perpetual",
    expiryTimestamp,
    planVersion: "initial"
  };
};
var decodeLicenseVersion2 = (license) => {
  const licenseInfo = {
    scope: null,
    licensingModel: null,
    expiryTimestamp: null,
    planVersion: "initial"
  };
  license.split(",").map((token) => token.split("=")).filter((el) => el.length === 2).forEach(([key, value]) => {
    if (key === "S") {
      licenseInfo.scope = value;
    }
    if (key === "LM") {
      licenseInfo.licensingModel = value;
    }
    if (key === "E") {
      const expiryTimestamp = parseInt(value, 10);
      if (expiryTimestamp && !Number.isNaN(expiryTimestamp)) {
        licenseInfo.expiryTimestamp = expiryTimestamp;
      }
    }
    if (key === "PV") {
      licenseInfo.planVersion = value;
    }
  });
  return licenseInfo;
};
var decodeLicense = (encodedLicense) => {
  const license = base64Decode(encodedLicense);
  if (license.includes("KEYVERSION=1")) {
    return decodeLicenseVersion1(license);
  }
  if (license.includes("KV=2")) {
    return decodeLicenseVersion2(license);
  }
  return null;
};
function verifyLicense({
  releaseInfo: releaseInfo5,
  licenseKey,
  packageName
}) {
  if (!releaseInfo5) {
    throw new Error("MUI X: The release information is missing. Not able to validate license.");
  }
  if (!licenseKey) {
    return {
      status: LICENSE_STATUS.NotFound
    };
  }
  const hash = licenseKey.substr(0, 32);
  const encoded = licenseKey.substr(32);
  if (hash !== md5(encoded)) {
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  const license = decodeLicense(encoded);
  if (license == null) {
    console.error("MUI X: Error checking license. Key version not found!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (license.licensingModel == null || !LICENSING_MODELS.includes(license.licensingModel)) {
    console.error("MUI X: Error checking license. Licensing model not found or invalid!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (license.expiryTimestamp == null) {
    console.error("MUI X: Error checking license. Expiry timestamp not found or invalid!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (license.licensingModel === "perpetual" || false) {
    const pkgTimestamp = parseInt(base64Decode(releaseInfo5), 10);
    if (Number.isNaN(pkgTimestamp)) {
      throw new Error("MUI X: The release information is invalid. Not able to validate license.");
    }
    if (license.expiryTimestamp < pkgTimestamp) {
      return {
        status: LICENSE_STATUS.ExpiredVersion
      };
    }
  } else if (license.licensingModel === "subscription" || license.licensingModel === "annual") {
    if ((/* @__PURE__ */ new Date()).getTime() > license.expiryTimestamp) {
      if (
        // 30 days grace
        (/* @__PURE__ */ new Date()).getTime() < license.expiryTimestamp + 1e3 * 3600 * 24 * 30 || false
      ) {
        return {
          status: LICENSE_STATUS.ExpiredAnnualGrace,
          meta: {
            expiryTimestamp: license.expiryTimestamp,
            licenseKey
          }
        };
      }
      return {
        status: LICENSE_STATUS.ExpiredAnnual,
        meta: {
          expiryTimestamp: license.expiryTimestamp,
          licenseKey
        }
      };
    }
  }
  if (license.scope == null || !LICENSE_SCOPES.includes(license.scope)) {
    console.error("MUI X: Error checking license. scope not found or invalid!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (!isLicenseScopeSufficient(packageName, license.scope)) {
    return {
      status: LICENSE_STATUS.OutOfScope
    };
  }
  if (license.planVersion === "initial" && license.scope === "pro" && !PRO_PACKAGES_AVAILABLE_IN_INITIAL_PRO_PLAN.includes(packageName)) {
    return {
      status: LICENSE_STATUS.NotAvailableInInitialProPlan
    };
  }
  return {
    status: LICENSE_STATUS.Valid
  };
}

// node_modules/@mui/x-license/useLicenseVerifier/useLicenseVerifier.js
init_extends();
var React2 = __toESM(require_react());

// node_modules/@mui/x-license/Unstable_LicenseInfoProvider/MuiLicenseInfoContext.js
var React = __toESM(require_react());
var MuiLicenseInfoContext = React.createContext({
  key: void 0
});
if (true) {
  MuiLicenseInfoContext.displayName = "MuiLicenseInfoContext";
}
var MuiLicenseInfoContext_default = MuiLicenseInfoContext;

// node_modules/@mui/x-license/useLicenseVerifier/useLicenseVerifier.js
var sharedLicenseStatuses = {};
function useLicenseVerifier(packageName, releaseInfo5) {
  const {
    key: contextKey
  } = React2.useContext(MuiLicenseInfoContext_default);
  return React2.useMemo(() => {
    const licenseKey = contextKey ?? LicenseInfo.getLicenseKey();
    if (sharedLicenseStatuses[packageName] && sharedLicenseStatuses[packageName].key === licenseKey) {
      return sharedLicenseStatuses[packageName].licenseVerifier;
    }
    const plan = packageName.includes("premium") ? "Premium" : "Pro";
    const licenseStatus = verifyLicense({
      releaseInfo: releaseInfo5,
      licenseKey,
      packageName
    });
    const fullPackageName = `@mui/${packageName}`;
    if (licenseStatus.status === LICENSE_STATUS.Valid) {
    } else if (licenseStatus.status === LICENSE_STATUS.Invalid) {
      showInvalidLicenseKeyError();
    } else if (licenseStatus.status === LICENSE_STATUS.NotAvailableInInitialProPlan) {
      showNotAvailableInInitialProPlanError();
    } else if (licenseStatus.status === LICENSE_STATUS.OutOfScope) {
      showLicenseKeyPlanMismatchError();
    } else if (licenseStatus.status === LICENSE_STATUS.NotFound) {
      showMissingLicenseKeyError({
        plan,
        packageName: fullPackageName
      });
    } else if (licenseStatus.status === LICENSE_STATUS.ExpiredAnnualGrace) {
      showExpiredAnnualGraceLicenseKeyError(_extends({
        plan
      }, licenseStatus.meta));
    } else if (licenseStatus.status === LICENSE_STATUS.ExpiredAnnual) {
      showExpiredAnnualLicenseKeyError(_extends({
        plan
      }, licenseStatus.meta));
    } else if (licenseStatus.status === LICENSE_STATUS.ExpiredVersion) {
      showExpiredPackageVersionError({
        packageName: fullPackageName
      });
    } else if (true) {
      throw new Error("missing status handler");
    }
    sharedLicenseStatuses[packageName] = {
      key: licenseKey,
      licenseVerifier: licenseStatus
    };
    return licenseStatus;
  }, [packageName, releaseInfo5, contextKey]);
}

// node_modules/@mui/x-license/Watermark/Watermark.js
var React3 = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
function getLicenseErrorMessage(licenseStatus) {
  switch (licenseStatus) {
    case LICENSE_STATUS.ExpiredAnnualGrace:
    case LICENSE_STATUS.ExpiredAnnual:
      return "MUI X Expired license key";
    case LICENSE_STATUS.ExpiredVersion:
      return "MUI X Expired package version";
    case LICENSE_STATUS.Invalid:
      return "MUI X Invalid license key";
    case LICENSE_STATUS.OutOfScope:
      return "MUI X License key plan mismatch";
    case LICENSE_STATUS.NotAvailableInInitialProPlan:
      return "MUI X Product not covered by plan";
    case LICENSE_STATUS.NotFound:
      return "MUI X Missing license key";
    default:
      throw new Error("Unhandled MUI X license status.");
  }
}
function Watermark(props) {
  const {
    packageName,
    releaseInfo: releaseInfo5
  } = props;
  const licenseStatus = useLicenseVerifier(packageName, releaseInfo5);
  if (licenseStatus.status === LICENSE_STATUS.Valid) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)("div", {
    style: {
      position: "absolute",
      pointerEvents: "none",
      color: "#8282829e",
      zIndex: 1e5,
      width: "100%",
      textAlign: "center",
      bottom: "50%",
      right: 0,
      letterSpacing: 5,
      fontSize: 24
    },
    children: getLicenseErrorMessage(licenseStatus.status)
  });
}

// node_modules/@mui/x-license/Unstable_LicenseInfoProvider/LicenseInfoProvider.js
var React4 = __toESM(require_react());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());

// node_modules/@mui/x-date-pickers-pro/DateRangePickerDay/DateRangePickerDay.js
init_objectWithoutPropertiesLoose();
init_extends();
var React5 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
init_clsx();
init_composeClasses();

// node_modules/@mui/x-date-pickers/internals/components/pickersToolbarButtonClasses.js
init_esm();
var pickersToolbarButtonClasses = generateUtilityClasses("MuiPickersToolbarButton", ["root"]);

// node_modules/@mui/x-date-pickers-pro/DateRangePickerDay/dateRangePickerDayClasses.js
init_esm();
function getDateRangePickerDayUtilityClass(slot) {
  return generateUtilityClass("MuiDateRangePickerDay", slot);
}
var dateRangePickerDayClasses = generateUtilityClasses("MuiDateRangePickerDay", ["root", "rangeIntervalDayHighlight", "rangeIntervalDayHighlightStart", "rangeIntervalDayHighlightEnd", "rangeIntervalPreview", "rangeIntervalDayPreview", "rangeIntervalDayPreviewStart", "rangeIntervalDayPreviewEnd", "outsideCurrentMonth", "startOfMonth", "endOfMonth", "firstVisibleCell", "lastVisibleCell", "hiddenDayFiller", "day", "dayOutsideRangeInterval", "dayInsideRangeInterval", "notSelectedDate"]);

// node_modules/@mui/x-date-pickers-pro/internals/utils/releaseInfo.js
init_esm();
var getReleaseInfo = () => {
  const releaseInfo5 = "MTcyMzE1NDQwMDAwMA==";
  if (true) {
    if (releaseInfo5 === "__RELEASE_INFO__") {
      return ponyfillGlobal_default.__MUI_RELEASE_INFO__;
    }
  }
  return releaseInfo5;
};

// node_modules/@mui/x-date-pickers-pro/DateRangePickerDay/DateRangePickerDay.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var _excluded = ["className", "day", "outsideCurrentMonth", "isEndOfHighlighting", "isEndOfPreviewing", "isHighlighting", "isPreviewing", "isStartOfHighlighting", "isStartOfPreviewing", "selected", "isVisuallySelected", "sx", "draggable", "isFirstVisibleCell", "isLastVisibleCell"];
var releaseInfo = getReleaseInfo();
var useUtilityClasses = (ownerState) => {
  const {
    isHighlighting,
    outsideCurrentMonth,
    isStartOfHighlighting,
    isStartOfMonth,
    isEndOfHighlighting,
    isEndOfMonth,
    isPreviewing,
    isStartOfPreviewing,
    isEndOfPreviewing,
    isFirstVisibleCell,
    isLastVisibleCell,
    isHiddenDayFiller,
    selected,
    classes
  } = ownerState;
  const slots = {
    root: ["root", isHighlighting && "rangeIntervalDayHighlight", isStartOfHighlighting && "rangeIntervalDayHighlightStart", isEndOfHighlighting && "rangeIntervalDayHighlightEnd", outsideCurrentMonth && "outsideCurrentMonth", isStartOfMonth && "startOfMonth", isEndOfMonth && "endOfMonth", isFirstVisibleCell && "firstVisibleCell", isLastVisibleCell && "lastVisibleCell", isHiddenDayFiller && "hiddenDayFiller"],
    rangeIntervalPreview: ["rangeIntervalPreview", isPreviewing && "rangeIntervalDayPreview", (isStartOfPreviewing || isStartOfMonth) && "rangeIntervalDayPreviewStart", (isEndOfPreviewing || isEndOfMonth) && "rangeIntervalDayPreviewEnd"],
    day: ["day", !selected && "notSelectedDate", !isHighlighting && "dayOutsideRangeInterval", !selected && isHighlighting && "dayInsideRangeInterval"]
  };
  return composeClasses(slots, getDateRangePickerDayUtilityClass, classes);
};
var endBorderStyle = {
  borderTopRightRadius: "50%",
  borderBottomRightRadius: "50%"
};
var startBorderStyle = {
  borderTopLeftRadius: "50%",
  borderBottomLeftRadius: "50%"
};
var DateRangePickerDayRoot = styled_default("div", {
  name: "MuiDateRangePickerDay",
  slot: "Root",
  overridesResolver: (_, styles) => [{
    [`&.${dateRangePickerDayClasses.rangeIntervalDayHighlight}`]: styles.rangeIntervalDayHighlight
  }, {
    [`&.${dateRangePickerDayClasses.rangeIntervalDayHighlightStart}`]: styles.rangeIntervalDayHighlightStart
  }, {
    [`&.${dateRangePickerDayClasses.rangeIntervalDayHighlightEnd}`]: styles.rangeIntervalDayHighlightEnd
  }, {
    [`&.${dateRangePickerDayClasses.firstVisibleCell}`]: styles.firstVisibleCell
  }, {
    [`&.${dateRangePickerDayClasses.lastVisibleCell}`]: styles.lastVisibleCell
  }, {
    [`&.${dateRangePickerDayClasses.startOfMonth}`]: styles.startOfMonth
  }, {
    [`&.${dateRangePickerDayClasses.endOfMonth}`]: styles.endOfMonth
  }, {
    [`&.${dateRangePickerDayClasses.outsideCurrentMonth}`]: styles.outsideCurrentMonth
  }, {
    [`&.${dateRangePickerDayClasses.hiddenDayFiller}`]: styles.hiddenDayFiller
  }, styles.root]
})(({
  theme
}) => ({
  variants: [{
    props: {
      isHiddenDayFiller: false
    },
    style: {
      [`&:first-of-type .${dateRangePickerDayClasses.rangeIntervalDayPreview}`]: _extends({}, startBorderStyle, {
        borderLeftColor: (theme.vars || theme).palette.divider
      }),
      [`&:last-of-type .${dateRangePickerDayClasses.rangeIntervalDayPreview}`]: _extends({}, endBorderStyle, {
        borderRightColor: (theme.vars || theme).palette.divider
      })
    }
  }, {
    props: {
      isHiddenDayFiller: false,
      isHighlighting: true
    },
    style: {
      borderRadius: 0,
      color: (theme.vars || theme).palette.primary.contrastText,
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.focusOpacity),
      "&:first-of-type": startBorderStyle,
      "&:last-of-type": endBorderStyle
    }
  }, {
    props: ({
      ownerState: {
        isHiddenDayFiller,
        isStartOfHighlighting,
        isFirstVisibleCell
      }
    }) => !isHiddenDayFiller && (isStartOfHighlighting || isFirstVisibleCell),
    style: _extends({}, startBorderStyle, {
      paddingLeft: 0
    })
  }, {
    props: ({
      ownerState: {
        isHiddenDayFiller,
        isEndOfHighlighting,
        isLastVisibleCell
      }
    }) => !isHiddenDayFiller && (isEndOfHighlighting || isLastVisibleCell),
    style: _extends({}, endBorderStyle, {
      paddingRight: 0
    })
  }]
}));
var DateRangePickerDayRangeIntervalPreview = styled_default("div", {
  name: "MuiDateRangePickerDay",
  slot: "RangeIntervalPreview",
  overridesResolver: (_, styles) => [{
    [`&.${dateRangePickerDayClasses.rangeIntervalDayPreview}`]: styles.rangeIntervalDayPreview
  }, {
    [`&.${dateRangePickerDayClasses.rangeIntervalDayPreviewStart}`]: styles.rangeIntervalDayPreviewStart
  }, {
    [`&.${dateRangePickerDayClasses.rangeIntervalDayPreviewEnd}`]: styles.rangeIntervalDayPreviewEnd
  }, styles.rangeIntervalPreview]
})(({
  theme
}) => ({
  // replace default day component margin with transparent border to avoid jumping on preview
  border: "2px solid transparent",
  variants: [{
    props: {
      isPreviewing: true,
      isHiddenDayFiller: false
    },
    style: {
      borderRadius: 0,
      border: `2px dashed ${(theme.vars || theme).palette.divider}`,
      borderLeftColor: "transparent",
      borderRightColor: "transparent"
    }
  }, {
    props: ({
      ownerState: {
        isPreviewing,
        isHiddenDayFiller,
        isStartOfPreviewing,
        isFirstVisibleCell
      }
    }) => isPreviewing && !isHiddenDayFiller && (isStartOfPreviewing || isFirstVisibleCell),
    style: _extends({
      borderLeftColor: (theme.vars || theme).palette.divider
    }, startBorderStyle)
  }, {
    props: ({
      ownerState: {
        isPreviewing,
        isHiddenDayFiller,
        isEndOfPreviewing,
        isLastVisibleCell
      }
    }) => isPreviewing && !isHiddenDayFiller && (isEndOfPreviewing || isLastVisibleCell),
    style: _extends({
      borderRightColor: (theme.vars || theme).palette.divider
    }, endBorderStyle)
  }]
}));
var DateRangePickerDayDay = styled_default(PickersDay, {
  name: "MuiDateRangePickerDay",
  slot: "Day",
  overridesResolver: (_, styles) => [{
    [`&.${dateRangePickerDayClasses.dayInsideRangeInterval}`]: styles.dayInsideRangeInterval
  }, {
    [`&.${dateRangePickerDayClasses.dayOutsideRangeInterval}`]: styles.dayOutsideRangeInterval
  }, {
    [`&.${dateRangePickerDayClasses.notSelectedDate}`]: styles.notSelectedDate
  }, styles.day]
})({
  // Required to overlap preview border
  transform: "scale(1.1)",
  "& > *": {
    transform: "scale(0.9)"
  },
  variants: [{
    props: {
      draggable: true
    },
    style: {
      cursor: "grab",
      touchAction: "none"
    }
  }]
});
var DateRangePickerDayRaw = React5.forwardRef(function DateRangePickerDay(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDateRangePickerDay"
  });
  const {
    className,
    day,
    outsideCurrentMonth,
    isHighlighting,
    isPreviewing,
    selected = false,
    isVisuallySelected,
    sx,
    draggable,
    isFirstVisibleCell,
    isLastVisibleCell
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
  useLicenseVerifier("x-date-pickers-pro", releaseInfo);
  const utils = useUtils();
  const isEndOfMonth = utils.isSameDay(day, utils.endOfMonth(day));
  const isStartOfMonth = utils.isSameDay(day, utils.startOfMonth(day));
  const shouldRenderHighlight = isHighlighting && !outsideCurrentMonth;
  const shouldRenderPreview = isPreviewing && !outsideCurrentMonth;
  const ownerState = _extends({}, props, {
    selected,
    isStartOfMonth,
    isEndOfMonth,
    draggable,
    isFirstVisibleCell,
    isLastVisibleCell,
    isHiddenDayFiller: outsideCurrentMonth && !other.showDaysOutsideCurrentMonth
  });
  const classes = useUtilityClasses(ownerState);
  return (0, import_jsx_runtime3.jsx)(DateRangePickerDayRoot, {
    className: clsx_default(classes.root, className),
    ownerState,
    sx,
    children: (0, import_jsx_runtime3.jsx)(DateRangePickerDayRangeIntervalPreview, {
      className: classes.rangeIntervalPreview,
      ownerState,
      children: (0, import_jsx_runtime3.jsx)(DateRangePickerDayDay, _extends({}, other, {
        ref,
        disableMargin: true,
        day,
        selected: isVisuallySelected,
        outsideCurrentMonth,
        className: classes.day,
        ownerState,
        draggable,
        isFirstVisibleCell,
        isLastVisibleCell
      }))
    })
  });
});
true ? DateRangePickerDayRaw.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * A ref for imperative actions.
   * It currently only supports `focusVisible()` action.
   */
  action: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.shape({
    current: import_prop_types.default.shape({
      focusVisible: import_prop_types.default.func.isRequired
    })
  })]),
  /**
   * If `true`, the ripples are centered.
   * They won't start at the cursor interaction position.
   * @default false
   */
  centerRipple: import_prop_types.default.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types.default.object,
  className: import_prop_types.default.string,
  component: import_prop_types.default.elementType,
  /**
   * The date to show.
   */
  day: import_prop_types.default.object.isRequired,
  /**
   * If `true`, renders as disabled.
   * @default false
   */
  disabled: import_prop_types.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types.default.bool,
  /**
   * If `true`, days are rendering without margin. Useful for displaying linked range of days.
   * @default false
   */
  disableMargin: import_prop_types.default.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: import_prop_types.default.bool,
  /**
   * If `true`, the touch ripple effect is disabled.
   * @default false
   */
  disableTouchRipple: import_prop_types.default.bool,
  /**
   * If `true`, the day can be dragged to change the current date range.
   * @default false
   */
  draggable: import_prop_types.default.bool,
  /**
   * If `true`, the base button will have a keyboard focus ripple.
   * @default false
   */
  focusRipple: import_prop_types.default.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: import_prop_types.default.string,
  isAnimating: import_prop_types.default.bool,
  /**
   * Set to `true` if the `day` is the end of a highlighted date range.
   */
  isEndOfHighlighting: import_prop_types.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is the end of a previewing date range.
   */
  isEndOfPreviewing: import_prop_types.default.bool.isRequired,
  /**
   * If `true`, day is the first visible cell of the month.
   * Either the first day of the month or the first day of the week depending on `showDaysOutsideCurrentMonth`.
   */
  isFirstVisibleCell: import_prop_types.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is in a highlighted date range.
   */
  isHighlighting: import_prop_types.default.bool.isRequired,
  /**
   * If `true`, day is the last visible cell of the month.
   * Either the last day of the month or the last day of the week depending on `showDaysOutsideCurrentMonth`.
   */
  isLastVisibleCell: import_prop_types.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is in a preview date range.
   */
  isPreviewing: import_prop_types.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is the start of a highlighted date range.
   */
  isStartOfHighlighting: import_prop_types.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is the start of a previewing date range.
   */
  isStartOfPreviewing: import_prop_types.default.bool.isRequired,
  /**
   * Indicates if the day should be visually selected.
   */
  isVisuallySelected: import_prop_types.default.bool,
  onDaySelect: import_prop_types.default.func.isRequired,
  /**
   * Callback fired when the component is focused with a keyboard.
   * We trigger a `onFocus` callback too.
   */
  onFocusVisible: import_prop_types.default.func,
  onMouseEnter: import_prop_types.default.func,
  /**
   * If `true`, day is outside of month and will be hidden.
   */
  outsideCurrentMonth: import_prop_types.default.bool.isRequired,
  /**
   * If `true`, renders as selected.
   * @default false
   */
  selected: import_prop_types.default.bool,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types.default.bool,
  style: import_prop_types.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
  /**
   * @default 0
   */
  tabIndex: import_prop_types.default.number,
  /**
   * If `true`, renders as today date.
   * @default false
   */
  today: import_prop_types.default.bool,
  /**
   * Props applied to the `TouchRipple` element.
   */
  TouchRippleProps: import_prop_types.default.object,
  /**
   * A ref that points to the `TouchRipple` element.
   */
  touchRippleRef: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.shape({
    current: import_prop_types.default.shape({
      pulsate: import_prop_types.default.func.isRequired,
      start: import_prop_types.default.func.isRequired,
      stop: import_prop_types.default.func.isRequired
    })
  })])
} : void 0;
var DateRangePickerDay2 = React5.memo(DateRangePickerDayRaw);

// node_modules/@mui/x-date-pickers-pro/MultiInputDateRangeField/MultiInputDateRangeField.js
init_objectWithoutPropertiesLoose();
init_extends();
var React7 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());
init_clsx();
init_useSlotProps();
init_esm();

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMultiInputRangeField/useMultiInputDateRangeField.js
init_extends();
init_useEventCallback();

// node_modules/@mui/x-date-pickers-pro/internals/utils/validation/validateDateRange.js
init_extends();
init_objectWithoutPropertiesLoose();

// node_modules/@mui/x-date-pickers-pro/internals/utils/date-utils.js
var isRangeValid = (utils, range) => {
  return Boolean(range && range[0] && range[1] && !utils.isBefore(range[1], range[0]));
};
var isWithinRange = (utils, day, range) => {
  return isRangeValid(utils, range) && utils.isWithinRange(day, range);
};
var isStartOfRange = (utils, day, range) => {
  return isRangeValid(utils, range) && utils.isSameDay(day, range[0]);
};
var isEndOfRange = (utils, day, range) => {
  return isRangeValid(utils, range) && utils.isSameDay(day, range[1]);
};

// node_modules/@mui/x-date-pickers-pro/internals/utils/validation/validateDateRange.js
var _excluded2 = ["shouldDisableDate"];
var validateDateRange = ({
  props,
  value,
  adapter
}) => {
  const [start, end] = value;
  const {
    shouldDisableDate
  } = props, otherProps = _objectWithoutPropertiesLoose(props, _excluded2);
  const dateValidations = [validateDate({
    adapter,
    value: start,
    props: _extends({}, otherProps, {
      shouldDisableDate: (day) => !!(shouldDisableDate == null ? void 0 : shouldDisableDate(day, "start"))
    })
  }), validateDate({
    adapter,
    value: end,
    props: _extends({}, otherProps, {
      shouldDisableDate: (day) => !!(shouldDisableDate == null ? void 0 : shouldDisableDate(day, "end"))
    })
  })];
  if (dateValidations[0] || dateValidations[1]) {
    return dateValidations;
  }
  if (start === null || end === null) {
    return [null, null];
  }
  if (!isRangeValid(adapter.utils, value)) {
    return ["invalidRange", "invalidRange"];
  }
  return [null, null];
};

// node_modules/@mui/x-date-pickers-pro/internals/utils/valueManagers.js
init_extends();
init_objectWithoutPropertiesLoose();

// node_modules/@mui/x-date-pickers-pro/internals/utils/date-fields-utils.js
init_extends();
var splitDateRangeSections = (sections) => {
  const startDateSections = [];
  const endDateSections = [];
  sections.forEach((section) => {
    if (section.dateName === "start") {
      startDateSections.push(section);
    } else {
      endDateSections.push(section);
    }
  });
  return {
    startDate: startDateSections,
    endDate: endDateSections
  };
};
var removeLastSeparator = (dateSections) => dateSections.map((section, sectionIndex) => {
  if (sectionIndex === dateSections.length - 1) {
    return _extends({}, section, {
      separator: null
    });
  }
  return section;
});

// node_modules/@mui/x-date-pickers-pro/internals/utils/valueManagers.js
var _excluded3 = ["value", "referenceDate"];
var rangeValueManager = {
  emptyValue: [null, null],
  getTodayValue: (utils, timezone, valueType) => [getTodayDate(utils, timezone, valueType), getTodayDate(utils, timezone, valueType)],
  getInitialReferenceValue: (_ref) => {
    let {
      value,
      referenceDate: referenceDateProp
    } = _ref, params = _objectWithoutPropertiesLoose(_ref, _excluded3);
    const shouldKeepStartDate = value[0] != null && params.utils.isValid(value[0]);
    const shouldKeepEndDate = value[1] != null && params.utils.isValid(value[1]);
    if (shouldKeepStartDate && shouldKeepEndDate) {
      return value;
    }
    const referenceDate = referenceDateProp ?? getDefaultReferenceDate(params);
    return [shouldKeepStartDate ? value[0] : referenceDate, shouldKeepEndDate ? value[1] : referenceDate];
  },
  cleanValue: (utils, value) => value.map((date) => replaceInvalidDateByNull(utils, date)),
  areValuesEqual: (utils, a, b) => areDatesEqual(utils, a[0], b[0]) && areDatesEqual(utils, a[1], b[1]),
  isSameError: (a, b) => b !== null && a[1] === b[1] && a[0] === b[0],
  hasError: (error) => error[0] != null || error[1] != null,
  defaultErrorState: [null, null],
  getTimezone: (utils, value) => {
    const timezoneStart = value[0] == null || !utils.isValid(value[0]) ? null : utils.getTimezone(value[0]);
    const timezoneEnd = value[1] == null || !utils.isValid(value[1]) ? null : utils.getTimezone(value[1]);
    if (timezoneStart != null && timezoneEnd != null && timezoneStart !== timezoneEnd) {
      throw new Error("MUI X: The timezone of the start and the end date should be the same.");
    }
    return timezoneStart ?? timezoneEnd;
  },
  setTimezone: (utils, timezone, value) => [value[0] == null ? null : utils.setTimezone(value[0], timezone), value[1] == null ? null : utils.setTimezone(value[1], timezone)]
};
var getRangeFieldValueManager = ({
  dateSeparator = "–"
}) => ({
  updateReferenceValue: (utils, value, prevReferenceValue) => {
    const shouldKeepStartDate = value[0] != null && utils.isValid(value[0]);
    const shouldKeepEndDate = value[1] != null && utils.isValid(value[1]);
    if (!shouldKeepStartDate && !shouldKeepEndDate) {
      return prevReferenceValue;
    }
    if (shouldKeepStartDate && shouldKeepEndDate) {
      return value;
    }
    if (shouldKeepStartDate) {
      return [value[0], prevReferenceValue[0]];
    }
    return [prevReferenceValue[1], value[1]];
  },
  getSectionsFromValue: (utils, [start, end], fallbackSections, getSectionsFromDate) => {
    const separatedFallbackSections = fallbackSections == null ? {
      startDate: null,
      endDate: null
    } : splitDateRangeSections(fallbackSections);
    const getSections = (newDate, fallbackDateSections, position) => {
      const shouldReUsePrevDateSections = !utils.isValid(newDate) && !!fallbackDateSections;
      if (shouldReUsePrevDateSections) {
        return fallbackDateSections;
      }
      const sections = getSectionsFromDate(newDate);
      return sections.map((section, sectionIndex) => {
        if (sectionIndex === sections.length - 1 && position === "start") {
          return _extends({}, section, {
            dateName: position,
            // TODO: Check if RTL still works
            endSeparator: `${section.endSeparator} ${dateSeparator} `
          });
        }
        return _extends({}, section, {
          dateName: position
        });
      });
    };
    return [...getSections(start, separatedFallbackSections.startDate, "start"), ...getSections(end, separatedFallbackSections.endDate, "end")];
  },
  getV7HiddenInputValueFromSections: (sections) => {
    const dateRangeSections = splitDateRangeSections(sections);
    return createDateStrForV7HiddenInputFromSections([...dateRangeSections.startDate, ...dateRangeSections.endDate]);
  },
  getV6InputValueFromSections: (sections, localizedDigits, isRtl) => {
    const dateRangeSections = splitDateRangeSections(sections);
    return createDateStrForV6InputFromSections([...dateRangeSections.startDate, ...dateRangeSections.endDate], localizedDigits, isRtl);
  },
  parseValueStr: (valueStr, referenceValue, parseDate) => {
    const [startStr, endStr] = valueStr.split(dateSeparator);
    return [startStr, endStr].map((dateStr, index) => {
      if (dateStr == null) {
        return null;
      }
      return parseDate(dateStr.trim(), referenceValue[index]);
    });
  },
  getActiveDateManager: (utils, state, activeSection) => {
    const index = activeSection.dateName === "start" ? 0 : 1;
    const updateDateInRange = (newDate, prevDateRange) => index === 0 ? [newDate, prevDateRange[1]] : [prevDateRange[0], newDate];
    return {
      date: state.value[index],
      referenceDate: state.referenceValue[index],
      getSections: (sections) => {
        const dateRangeSections = splitDateRangeSections(sections);
        if (index === 0) {
          return removeLastSeparator(dateRangeSections.startDate);
        }
        return dateRangeSections.endDate;
      },
      getNewValuesFromNewActiveDate: (newActiveDate) => ({
        value: updateDateInRange(newActiveDate, state.value),
        referenceValue: newActiveDate == null || !utils.isValid(newActiveDate) ? state.referenceValue : updateDateInRange(newActiveDate, state.referenceValue)
      })
    };
  }
});

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMultiInputRangeField/shared.js
var excludeProps = (props, excludedProps) => {
  return Object.keys(props).reduce((acc, key) => {
    if (!excludedProps.includes(key)) {
      acc[key] = props[key];
    }
    return acc;
  }, {});
};

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMultiInputFieldSelectedSections.js
var React6 = __toESM(require_react());
init_useForkRef();
init_useEventCallback();
var useMultiInputFieldSelectedSections = (params) => {
  const unstableEndFieldRef = React6.useRef(null);
  const handleUnstableEndFieldRef = useForkRef(params.unstableEndFieldRef, unstableEndFieldRef);
  const [startSelectedSection, setStartSelectedSection] = React6.useState(params.selectedSections ?? null);
  const [endSelectedSection, setEndSelectedSection] = React6.useState(null);
  const getActiveField = () => {
    if (unstableEndFieldRef.current && unstableEndFieldRef.current.isFieldFocused()) {
      return "end";
    }
    return "start";
  };
  const handleStartSelectedSectionChange = useEventCallback_default((newSelectedSections) => {
    var _a;
    setStartSelectedSection(newSelectedSections);
    if (getActiveField() === "start") {
      (_a = params.onSelectedSectionsChange) == null ? void 0 : _a.call(params, newSelectedSections);
    }
  });
  const handleEndSelectedSectionChange = useEventCallback_default((newSelectedSections) => {
    var _a;
    setEndSelectedSection(newSelectedSections);
    if (getActiveField() === "end") {
      (_a = params.onSelectedSectionsChange) == null ? void 0 : _a.call(params, newSelectedSections);
    }
  });
  const activeField = getActiveField();
  return {
    start: {
      unstableFieldRef: params.unstableStartFieldRef,
      selectedSections: activeField === "start" && params.selectedSections !== void 0 ? params.selectedSections : startSelectedSection,
      onSelectedSectionsChange: handleStartSelectedSectionChange
    },
    end: {
      unstableFieldRef: handleUnstableEndFieldRef,
      selectedSections: activeField === "end" && params.selectedSections !== void 0 ? params.selectedSections : endSelectedSection,
      onSelectedSectionsChange: handleEndSelectedSectionChange
    }
  };
};

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMultiInputRangeField/useMultiInputDateRangeField.js
var useMultiInputDateRangeField = ({
  sharedProps: inSharedProps,
  startTextFieldProps,
  unstableStartFieldRef,
  endTextFieldProps,
  unstableEndFieldRef
}) => {
  const sharedProps = useDefaultizedDateField(inSharedProps);
  const adapter = useLocalizationContext();
  const {
    value: valueProp,
    defaultValue,
    format,
    formatDensity,
    shouldRespectLeadingZeros,
    onChange,
    disabled,
    readOnly,
    selectedSections,
    onSelectedSectionsChange,
    timezone: timezoneProp,
    enableAccessibleFieldDOMStructure,
    autoFocus
  } = sharedProps;
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "useMultiInputDateRangeField",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: rangeValueManager
  });
  const buildChangeHandler = (index) => {
    return (newDate, rawContext) => {
      const newDateRange = index === 0 ? [newDate, value[1]] : [value[0], newDate];
      const context = _extends({}, rawContext, {
        validationError: validateDateRange({
          adapter,
          value: newDateRange,
          props: _extends({}, sharedProps, {
            timezone
          })
        })
      });
      handleValueChange(newDateRange, context);
    };
  };
  const handleStartDateChange = useEventCallback_default(buildChangeHandler(0));
  const handleEndDateChange = useEventCallback_default(buildChangeHandler(1));
  const validationError = useValidation(_extends({}, sharedProps, {
    value,
    timezone
  }), validateDateRange, rangeValueManager.isSameError, rangeValueManager.defaultErrorState);
  const selectedSectionsResponse = useMultiInputFieldSelectedSections({
    selectedSections,
    onSelectedSectionsChange,
    unstableStartFieldRef,
    unstableEndFieldRef
  });
  const startFieldProps = _extends({
    error: !!validationError[0]
  }, startTextFieldProps, selectedSectionsResponse.start, {
    disabled,
    readOnly,
    format,
    formatDensity,
    shouldRespectLeadingZeros,
    timezone,
    value: valueProp === void 0 ? void 0 : valueProp[0],
    defaultValue: defaultValue === void 0 ? void 0 : defaultValue[0],
    onChange: handleStartDateChange,
    enableAccessibleFieldDOMStructure,
    autoFocus
    // Do not add on end field.
  });
  const endFieldProps = _extends({
    error: !!validationError[1]
  }, endTextFieldProps, selectedSectionsResponse.end, {
    format,
    formatDensity,
    shouldRespectLeadingZeros,
    disabled,
    readOnly,
    timezone,
    value: valueProp === void 0 ? void 0 : valueProp[1],
    defaultValue: defaultValue === void 0 ? void 0 : defaultValue[1],
    onChange: handleEndDateChange,
    enableAccessibleFieldDOMStructure
  });
  const startDateResponse = useDateField(startFieldProps);
  const endDateResponse = useDateField(endFieldProps);
  return {
    startDate: excludeProps(startDateResponse, ["clearable", "onClear"]),
    endDate: excludeProps(endDateResponse, ["clearable", "onClear"])
  };
};

// node_modules/@mui/x-date-pickers-pro/MultiInputDateRangeField/MultiInputDateRangeField.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var _excluded4 = ["slots", "slotProps", "unstableStartFieldRef", "unstableEndFieldRef", "className"];
var multiInputDateRangeFieldClasses = generateUtilityClasses("MuiMultiInputDateRangeField", ["root", "separator"]);
var getMultiInputDateRangeFieldUtilityClass = (slot) => generateUtilityClass("MuiMultiInputDateRangeField", slot);
var useUtilityClasses2 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    separator: ["separator"]
  };
  return composeClasses(slots, getMultiInputDateRangeFieldUtilityClass, classes);
};
var MultiInputDateRangeFieldRoot = styled_default(React7.forwardRef((props, ref) => (0, import_jsx_runtime4.jsx)(Stack_default, _extends({
  ref,
  spacing: 2,
  direction: "row",
  alignItems: "center"
}, props))), {
  name: "MuiMultiInputDateRangeField",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({});
var MultiInputDateRangeFieldSeparator = styled_default(Typography_default, {
  name: "MuiMultiInputDateRangeField",
  slot: "Separator",
  overridesResolver: (props, styles) => styles.separator
})({
  lineHeight: "1.4375em"
  // 23px
});
var MultiInputDateRangeField = React7.forwardRef(function MultiInputDateRangeField2(inProps, ref) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiMultiInputDateRangeField"
  });
  const {
    internalProps,
    forwardedProps
  } = splitFieldInternalAndForwardedProps(themeProps, "date");
  const {
    slots,
    slotProps,
    unstableStartFieldRef,
    unstableEndFieldRef,
    className
  } = forwardedProps, otherForwardedProps = _objectWithoutPropertiesLoose(forwardedProps, _excluded4);
  const ownerState = themeProps;
  const classes = useUtilityClasses2(ownerState);
  const Root = (slots == null ? void 0 : slots.root) ?? MultiInputDateRangeFieldRoot;
  const rootProps = useSlotProps_default({
    elementType: Root,
    externalSlotProps: slotProps == null ? void 0 : slotProps.root,
    externalForwardedProps: otherForwardedProps,
    additionalProps: {
      ref
    },
    ownerState,
    className: clsx_default(className, classes.root)
  });
  const TextField = (slots == null ? void 0 : slots.textField) ?? (inProps.enableAccessibleFieldDOMStructure ? PickersTextField : TextField_default);
  const startTextFieldProps = useSlotProps_default({
    elementType: TextField,
    externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
    ownerState: _extends({}, ownerState, {
      position: "start"
    })
  });
  const endTextFieldProps = useSlotProps_default({
    elementType: TextField,
    externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
    ownerState: _extends({}, ownerState, {
      position: "end"
    })
  });
  const Separator = (slots == null ? void 0 : slots.separator) ?? MultiInputDateRangeFieldSeparator;
  const separatorProps = useSlotProps_default({
    elementType: Separator,
    externalSlotProps: slotProps == null ? void 0 : slotProps.separator,
    additionalProps: {
      children: ` ${internalProps.dateSeparator ?? "–"} `
    },
    ownerState,
    className: classes.separator
  });
  const fieldResponse = useMultiInputDateRangeField({
    sharedProps: internalProps,
    startTextFieldProps,
    endTextFieldProps,
    unstableStartFieldRef,
    unstableEndFieldRef
  });
  const startDateProps = convertFieldResponseIntoMuiTextFieldProps(fieldResponse.startDate);
  const endDateProps = convertFieldResponseIntoMuiTextFieldProps(fieldResponse.endDate);
  return (0, import_jsx_runtime4.jsxs)(Root, _extends({}, rootProps, {
    children: [(0, import_jsx_runtime4.jsx)(TextField, _extends({
      fullWidth: true
    }, startDateProps)), (0, import_jsx_runtime4.jsx)(Separator, _extends({}, separatorProps)), (0, import_jsx_runtime4.jsx)(TextField, _extends({
      fullWidth: true
    }, endDateProps))]
  }));
});
true ? MultiInputDateRangeField.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: import_prop_types2.default.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types2.default.object,
  className: import_prop_types2.default.string,
  component: import_prop_types2.default.elementType,
  /**
   * String displayed between the start and the end dates.
   * @default "–"
   */
  dateSeparator: import_prop_types2.default.string,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: import_prop_types2.default.arrayOf(import_prop_types2.default.object),
  /**
   * Defines the `flex-direction` style property.
   * It is applied for all screen sizes.
   * @default 'column'
   */
  direction: import_prop_types2.default.oneOfType([import_prop_types2.default.oneOf(["column-reverse", "column", "row-reverse", "row"]), import_prop_types2.default.arrayOf(import_prop_types2.default.oneOf(["column-reverse", "column", "row-reverse", "row"])), import_prop_types2.default.object]),
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: import_prop_types2.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types2.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types2.default.bool,
  /**
   * Add an element between each child.
   */
  divider: import_prop_types2.default.node,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: import_prop_types2.default.bool,
  /**
   * Format of the date when rendered in the input(s).
   */
  format: import_prop_types2.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types2.default.oneOf(["dense", "spacious"]),
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: import_prop_types2.default.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: import_prop_types2.default.object,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types2.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types2.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types2.default.func,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   * @default false
   */
  readOnly: import_prop_types2.default.bool,
  /**
   * The date used to generate a part of the new value that is not present in the format when both `value` and `defaultValue` are empty.
   * For example, on time fields it will be used to determine the date to set.
   * @default The closest valid date using the validation props, except callbacks such as `shouldDisableDate`. Value is rounded to the most granular section used.
   */
  referenceDate: import_prop_types2.default.object,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types2.default.oneOfType([import_prop_types2.default.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types2.default.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types2.default.func,
  /**
   * If `true`, the format will respect the leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `8/16/2018`)
   * If `false`, the format will always add leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `08/16/2018`)
   *
   * Warning n°1: Luxon is not able to respect the leading zeroes when using macro tokens (e.g: "DD"), so `shouldRespectLeadingZeros={true}` might lead to inconsistencies when using `AdapterLuxon`.
   *
   * Warning n°2: When `shouldRespectLeadingZeros={true}`, the field will add an invisible character on the sections containing a single digit to make sure `onChange` is fired.
   * If you need to get the clean value from the input, you can remove this character using `input.value.replace(/\u200e/g, '')`.
   *
   * Warning n°3: When used in strict mode, dayjs and moment require to respect the leading zeros.
   * This mean that when using `shouldRespectLeadingZeros={false}`, if you retrieve the value directly from the input (not listening to `onChange`) and your format contains tokens without leading zeros, the value will not be parsed by your library.
   *
   * @default false
   */
  shouldRespectLeadingZeros: import_prop_types2.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types2.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types2.default.object,
  /**
   * Defines the space between immediate children.
   * @default 0
   */
  spacing: import_prop_types2.default.oneOfType([import_prop_types2.default.arrayOf(import_prop_types2.default.oneOfType([import_prop_types2.default.number, import_prop_types2.default.string])), import_prop_types2.default.number, import_prop_types2.default.object, import_prop_types2.default.string]),
  style: import_prop_types2.default.object,
  /**
   * The system prop, which allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types2.default.oneOfType([import_prop_types2.default.arrayOf(import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.object, import_prop_types2.default.bool])), import_prop_types2.default.func, import_prop_types2.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types2.default.string,
  unstableEndFieldRef: import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.object]),
  unstableStartFieldRef: import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.object]),
  /**
   * If `true`, the CSS flexbox `gap` is used instead of applying `margin` to children.
   *
   * While CSS `gap` removes the [known limitations](https://mui.com/joy-ui/react-stack/#limitations),
   * it is not fully supported in some browsers. We recommend checking https://caniuse.com/?search=flex%20gap before using this flag.
   *
   * To enable this flag globally, follow the [theme's default props](https://mui.com/material-ui/customization/theme-components/#default-props) configuration.
   * @default false
   */
  useFlexGap: import_prop_types2.default.bool,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types2.default.arrayOf(import_prop_types2.default.object)
} : void 0;

// node_modules/@mui/x-date-pickers-pro/MultiInputTimeRangeField/MultiInputTimeRangeField.js
init_objectWithoutPropertiesLoose();
init_extends();
var React8 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());
init_clsx();
init_useSlotProps();
init_esm();

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMultiInputRangeField/useMultiInputTimeRangeField.js
init_extends();
init_useEventCallback();

// node_modules/@mui/x-date-pickers-pro/internals/utils/validation/validateTimeRange.js
var validateTimeRange = ({
  props,
  value,
  adapter
}) => {
  const [start, end] = value;
  const dateTimeValidations = [validateTime({
    adapter,
    value: start,
    props
  }), validateTime({
    adapter,
    value: end,
    props
  })];
  if (dateTimeValidations[0] || dateTimeValidations[1]) {
    return dateTimeValidations;
  }
  if (start === null || end === null) {
    return [null, null];
  }
  if (!isRangeValid(adapter.utils, value)) {
    return ["invalidRange", "invalidRange"];
  }
  return [null, null];
};

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMultiInputRangeField/useMultiInputTimeRangeField.js
var useMultiInputTimeRangeField = ({
  sharedProps: inSharedProps,
  startTextFieldProps,
  unstableStartFieldRef,
  endTextFieldProps,
  unstableEndFieldRef
}) => {
  const sharedProps = useDefaultizedTimeField(inSharedProps);
  const adapter = useLocalizationContext();
  const {
    value: valueProp,
    defaultValue,
    format,
    formatDensity,
    shouldRespectLeadingZeros,
    onChange,
    disabled,
    readOnly,
    selectedSections,
    onSelectedSectionsChange,
    timezone: timezoneProp,
    enableAccessibleFieldDOMStructure,
    autoFocus
  } = sharedProps;
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "useMultiInputDateRangeField",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: rangeValueManager
  });
  const buildChangeHandler = (index) => {
    return (newDate, rawContext) => {
      const newDateRange = index === 0 ? [newDate, value[1]] : [value[0], newDate];
      const context = _extends({}, rawContext, {
        validationError: validateTimeRange({
          adapter,
          value: newDateRange,
          props: _extends({}, sharedProps, {
            timezone
          })
        })
      });
      handleValueChange(newDateRange, context);
    };
  };
  const handleStartDateChange = useEventCallback_default(buildChangeHandler(0));
  const handleEndDateChange = useEventCallback_default(buildChangeHandler(1));
  const validationError = useValidation(_extends({}, sharedProps, {
    value,
    timezone
  }), validateTimeRange, rangeValueManager.isSameError, rangeValueManager.defaultErrorState);
  const selectedSectionsResponse = useMultiInputFieldSelectedSections({
    selectedSections,
    onSelectedSectionsChange,
    unstableStartFieldRef,
    unstableEndFieldRef
  });
  const startFieldProps = _extends({
    error: !!validationError[0]
  }, startTextFieldProps, selectedSectionsResponse.start, {
    disabled,
    readOnly,
    format,
    formatDensity,
    shouldRespectLeadingZeros,
    timezone,
    value: valueProp === void 0 ? void 0 : valueProp[0],
    defaultValue: defaultValue === void 0 ? void 0 : defaultValue[0],
    onChange: handleStartDateChange,
    enableAccessibleFieldDOMStructure,
    autoFocus
    // Do not add on end field.
  });
  const endFieldProps = _extends({
    error: !!validationError[1]
  }, endTextFieldProps, selectedSectionsResponse.end, {
    format,
    formatDensity,
    shouldRespectLeadingZeros,
    disabled,
    readOnly,
    timezone,
    value: valueProp === void 0 ? void 0 : valueProp[1],
    defaultValue: defaultValue === void 0 ? void 0 : defaultValue[1],
    onChange: handleEndDateChange,
    enableAccessibleFieldDOMStructure
  });
  const startDateResponse = useTimeField(startFieldProps);
  const endDateResponse = useTimeField(endFieldProps);
  return {
    startDate: excludeProps(startDateResponse, ["clearable", "onClear"]),
    endDate: excludeProps(endDateResponse, ["clearable", "onClear"])
  };
};

// node_modules/@mui/x-date-pickers-pro/MultiInputTimeRangeField/MultiInputTimeRangeField.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var _excluded5 = ["slots", "slotProps", "unstableStartFieldRef", "unstableEndFieldRef", "className"];
var multiInputTimeRangeFieldClasses = generateUtilityClasses("MuiMultiInputTimeRangeField", ["root", "separator"]);
var getMultiInputTimeRangeFieldUtilityClass = (slot) => generateUtilityClass("MuiMultiInputTimeRangeField", slot);
var useUtilityClasses3 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    separator: ["separator"]
  };
  return composeClasses(slots, getMultiInputTimeRangeFieldUtilityClass, classes);
};
var MultiInputTimeRangeFieldRoot = styled_default(React8.forwardRef((props, ref) => (0, import_jsx_runtime5.jsx)(Stack_default, _extends({
  ref,
  spacing: 2,
  direction: "row",
  alignItems: "center"
}, props))), {
  name: "MuiMultiInputTimeRangeField",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({});
var MultiInputTimeRangeFieldSeparator = styled_default(Typography_default, {
  name: "MuiMultiInputTimeRangeField",
  slot: "Separator",
  overridesResolver: (props, styles) => styles.separator
})({
  lineHeight: "1.4375em"
  // 23px
});
var MultiInputTimeRangeField = React8.forwardRef(function MultiInputTimeRangeField2(inProps, ref) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiMultiInputTimeRangeField"
  });
  const {
    internalProps,
    forwardedProps
  } = splitFieldInternalAndForwardedProps(themeProps, "time");
  const {
    slots,
    slotProps,
    unstableStartFieldRef,
    unstableEndFieldRef,
    className
  } = forwardedProps, otherForwardedProps = _objectWithoutPropertiesLoose(forwardedProps, _excluded5);
  const ownerState = themeProps;
  const classes = useUtilityClasses3(ownerState);
  const Root = (slots == null ? void 0 : slots.root) ?? MultiInputTimeRangeFieldRoot;
  const rootProps = useSlotProps_default({
    elementType: Root,
    externalSlotProps: slotProps == null ? void 0 : slotProps.root,
    externalForwardedProps: otherForwardedProps,
    additionalProps: {
      ref
    },
    ownerState,
    className: clsx(className, classes.root)
  });
  const TextField = (slots == null ? void 0 : slots.textField) ?? (inProps.enableAccessibleFieldDOMStructure ? PickersTextField : TextField_default);
  const startTextFieldProps = useSlotProps_default({
    elementType: TextField,
    externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
    ownerState: _extends({}, ownerState, {
      position: "start"
    })
  });
  const endTextFieldProps = useSlotProps_default({
    elementType: TextField,
    externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
    ownerState: _extends({}, ownerState, {
      position: "end"
    })
  });
  const Separator = (slots == null ? void 0 : slots.separator) ?? MultiInputTimeRangeFieldSeparator;
  const separatorProps = useSlotProps_default({
    elementType: Separator,
    externalSlotProps: slotProps == null ? void 0 : slotProps.separator,
    additionalProps: {
      children: ` ${internalProps.dateSeparator ?? "–"} `
    },
    ownerState,
    className: classes.separator
  });
  const fieldResponse = useMultiInputTimeRangeField({
    sharedProps: internalProps,
    startTextFieldProps,
    endTextFieldProps,
    unstableStartFieldRef,
    unstableEndFieldRef
  });
  const startDateProps = convertFieldResponseIntoMuiTextFieldProps(fieldResponse.startDate);
  const endDateProps = convertFieldResponseIntoMuiTextFieldProps(fieldResponse.endDate);
  return (0, import_jsx_runtime5.jsxs)(Root, _extends({}, rootProps, {
    children: [(0, import_jsx_runtime5.jsx)(TextField, _extends({
      fullWidth: true
    }, startDateProps)), (0, import_jsx_runtime5.jsx)(Separator, _extends({}, separatorProps)), (0, import_jsx_runtime5.jsx)(TextField, _extends({
      fullWidth: true
    }, endDateProps))]
  }));
});
true ? MultiInputTimeRangeField.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default utils.is12HourCycleInCurrentLocale()
   */
  ampm: import_prop_types3.default.bool,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: import_prop_types3.default.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types3.default.object,
  className: import_prop_types3.default.string,
  component: import_prop_types3.default.elementType,
  /**
   * String displayed between the start and the end dates.
   * @default "–"
   */
  dateSeparator: import_prop_types3.default.string,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: import_prop_types3.default.arrayOf(import_prop_types3.default.object),
  /**
   * Defines the `flex-direction` style property.
   * It is applied for all screen sizes.
   * @default 'column'
   */
  direction: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["column-reverse", "column", "row-reverse", "row"]), import_prop_types3.default.arrayOf(import_prop_types3.default.oneOf(["column-reverse", "column", "row-reverse", "row"])), import_prop_types3.default.object]),
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: import_prop_types3.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types3.default.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: import_prop_types3.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types3.default.bool,
  /**
   * Add an element between each child.
   */
  divider: import_prop_types3.default.node,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: import_prop_types3.default.bool,
  /**
   * Format of the date when rendered in the input(s).
   */
  format: import_prop_types3.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types3.default.oneOf(["dense", "spacious"]),
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: import_prop_types3.default.object,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: import_prop_types3.default.object,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: import_prop_types3.default.number,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types3.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types3.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types3.default.func,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   * @default false
   */
  readOnly: import_prop_types3.default.bool,
  /**
   * The date used to generate a part of the new value that is not present in the format when both `value` and `defaultValue` are empty.
   * For example, on time fields it will be used to determine the date to set.
   * @default The closest valid date using the validation props, except callbacks such as `shouldDisableDate`. Value is rounded to the most granular section used.
   */
  referenceDate: import_prop_types3.default.object,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types3.default.number]),
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: import_prop_types3.default.func,
  /**
   * If `true`, the format will respect the leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `8/16/2018`)
   * If `false`, the format will always add leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `08/16/2018`)
   *
   * Warning n°1: Luxon is not able to respect the leading zeroes when using macro tokens (e.g: "DD"), so `shouldRespectLeadingZeros={true}` might lead to inconsistencies when using `AdapterLuxon`.
   *
   * Warning n°2: When `shouldRespectLeadingZeros={true}`, the field will add an invisible character on the sections containing a single digit to make sure `onChange` is fired.
   * If you need to get the clean value from the input, you can remove this character using `input.value.replace(/\u200e/g, '')`.
   *
   * Warning n°3: When used in strict mode, dayjs and moment require to respect the leading zeros.
   * This mean that when using `shouldRespectLeadingZeros={false}`, if you retrieve the value directly from the input (not listening to `onChange`) and your format contains tokens without leading zeros, the value will not be parsed by your library.
   *
   * @default false
   */
  shouldRespectLeadingZeros: import_prop_types3.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types3.default.object,
  /**
   * Overridable slots.
   * @default {}
   */
  slots: import_prop_types3.default.object,
  /**
   * Defines the space between immediate children.
   * @default 0
   */
  spacing: import_prop_types3.default.oneOfType([import_prop_types3.default.arrayOf(import_prop_types3.default.oneOfType([import_prop_types3.default.number, import_prop_types3.default.string])), import_prop_types3.default.number, import_prop_types3.default.object, import_prop_types3.default.string]),
  style: import_prop_types3.default.object,
  /**
   * The system prop, which allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types3.default.oneOfType([import_prop_types3.default.arrayOf(import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object, import_prop_types3.default.bool])), import_prop_types3.default.func, import_prop_types3.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types3.default.string,
  unstableEndFieldRef: import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object]),
  unstableStartFieldRef: import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object]),
  /**
   * If `true`, the CSS flexbox `gap` is used instead of applying `margin` to children.
   *
   * While CSS `gap` removes the [known limitations](https://mui.com/joy-ui/react-stack/#limitations),
   * it is not fully supported in some browsers. We recommend checking https://caniuse.com/?search=flex%20gap before using this flag.
   *
   * To enable this flag globally, follow the [theme's default props](https://mui.com/material-ui/customization/theme-components/#default-props) configuration.
   * @default false
   */
  useFlexGap: import_prop_types3.default.bool,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types3.default.arrayOf(import_prop_types3.default.object)
} : void 0;

// node_modules/@mui/x-date-pickers-pro/MultiInputDateTimeRangeField/MultiInputDateTimeRangeField.js
init_objectWithoutPropertiesLoose();
init_extends();
var React9 = __toESM(require_react());
var import_prop_types4 = __toESM(require_prop_types());
init_clsx();
init_useSlotProps();
init_esm();

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMultiInputRangeField/useMultiInputDateTimeRangeField.js
init_extends();
init_useEventCallback();

// node_modules/@mui/x-date-pickers-pro/internals/utils/validation/validateDateTimeRange.js
init_extends();
init_objectWithoutPropertiesLoose();
var _excluded6 = ["shouldDisableDate"];
var validateDateTimeRange = ({
  props,
  value,
  adapter
}) => {
  const [start, end] = value;
  const {
    shouldDisableDate
  } = props, otherProps = _objectWithoutPropertiesLoose(props, _excluded6);
  const dateTimeValidations = [validateDateTime({
    adapter,
    value: start,
    props: _extends({}, otherProps, {
      shouldDisableDate: (day) => !!(shouldDisableDate == null ? void 0 : shouldDisableDate(day, "start"))
    })
  }), validateDateTime({
    adapter,
    value: end,
    props: _extends({}, otherProps, {
      shouldDisableDate: (day) => !!(shouldDisableDate == null ? void 0 : shouldDisableDate(day, "end"))
    })
  })];
  if (dateTimeValidations[0] || dateTimeValidations[1]) {
    return dateTimeValidations;
  }
  if (start === null || end === null) {
    return [null, null];
  }
  if (!isRangeValid(adapter.utils, value)) {
    return ["invalidRange", "invalidRange"];
  }
  return [null, null];
};

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMultiInputRangeField/useMultiInputDateTimeRangeField.js
var useMultiInputDateTimeRangeField = ({
  sharedProps: inSharedProps,
  startTextFieldProps,
  unstableStartFieldRef,
  endTextFieldProps,
  unstableEndFieldRef
}) => {
  const sharedProps = useDefaultizedDateTimeField(inSharedProps);
  const adapter = useLocalizationContext();
  const {
    value: valueProp,
    defaultValue,
    format,
    formatDensity,
    shouldRespectLeadingZeros,
    onChange,
    disabled,
    readOnly,
    selectedSections,
    onSelectedSectionsChange,
    timezone: timezoneProp,
    enableAccessibleFieldDOMStructure,
    autoFocus
  } = sharedProps;
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "useMultiInputDateRangeField",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: rangeValueManager
  });
  const buildChangeHandler = (index) => {
    return (newDate, rawContext) => {
      const newDateRange = index === 0 ? [newDate, value[1]] : [value[0], newDate];
      const context = _extends({}, rawContext, {
        validationError: validateDateTimeRange({
          adapter,
          value: newDateRange,
          props: _extends({}, sharedProps, {
            timezone
          })
        })
      });
      handleValueChange(newDateRange, context);
    };
  };
  const handleStartDateChange = useEventCallback_default(buildChangeHandler(0));
  const handleEndDateChange = useEventCallback_default(buildChangeHandler(1));
  const validationError = useValidation(_extends({}, sharedProps, {
    value,
    timezone
  }), validateDateTimeRange, rangeValueManager.isSameError, rangeValueManager.defaultErrorState);
  const selectedSectionsResponse = useMultiInputFieldSelectedSections({
    selectedSections,
    onSelectedSectionsChange,
    unstableStartFieldRef,
    unstableEndFieldRef
  });
  const startFieldProps = _extends({
    error: !!validationError[0]
  }, startTextFieldProps, selectedSectionsResponse.start, {
    disabled,
    readOnly,
    format,
    formatDensity,
    shouldRespectLeadingZeros,
    timezone,
    value: valueProp === void 0 ? void 0 : valueProp[0],
    defaultValue: defaultValue === void 0 ? void 0 : defaultValue[0],
    onChange: handleStartDateChange,
    enableAccessibleFieldDOMStructure,
    autoFocus
    // Do not add on end field.
  });
  const endFieldProps = _extends({
    error: !!validationError[1]
  }, endTextFieldProps, selectedSectionsResponse.end, {
    format,
    formatDensity,
    shouldRespectLeadingZeros,
    disabled,
    readOnly,
    timezone,
    value: valueProp === void 0 ? void 0 : valueProp[1],
    defaultValue: defaultValue === void 0 ? void 0 : defaultValue[1],
    onChange: handleEndDateChange,
    enableAccessibleFieldDOMStructure
  });
  const startDateResponse = useDateTimeField(startFieldProps);
  const endDateResponse = useDateTimeField(endFieldProps);
  return {
    startDate: excludeProps(startDateResponse, ["clearable", "onClear"]),
    endDate: excludeProps(endDateResponse, ["clearable", "onClear"])
  };
};

// node_modules/@mui/x-date-pickers-pro/MultiInputDateTimeRangeField/MultiInputDateTimeRangeField.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var _excluded7 = ["slots", "slotProps", "unstableStartFieldRef", "unstableEndFieldRef", "className"];
var multiInputDateTimeRangeFieldClasses = generateUtilityClasses("MuiMultiInputDateTimeRangeField", ["root", "separator"]);
var getMultiInputDateTimeRangeFieldUtilityClass = (slot) => generateUtilityClass("MuiMultiInputDateTimeRangeField", slot);
var useUtilityClasses4 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    separator: ["separator"]
  };
  return composeClasses(slots, getMultiInputDateTimeRangeFieldUtilityClass, classes);
};
var MultiInputDateTimeRangeFieldRoot = styled_default(React9.forwardRef((props, ref) => (0, import_jsx_runtime6.jsx)(Stack_default, _extends({
  ref,
  spacing: 2,
  direction: "row",
  alignItems: "center"
}, props))), {
  name: "MuiMultiInputDateTimeRangeField",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({});
var MultiInputDateTimeRangeFieldSeparator = styled_default(Typography_default, {
  name: "MuiMultiInputDateTimeRangeField",
  slot: "Separator",
  overridesResolver: (props, styles) => styles.separator
})({
  lineHeight: "1.4375em"
  // 23px
});
var MultiInputDateTimeRangeField = React9.forwardRef(function MultiInputDateTimeRangeField2(inProps, ref) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiMultiInputDateTimeRangeField"
  });
  const {
    internalProps,
    forwardedProps
  } = splitFieldInternalAndForwardedProps(themeProps, "date-time");
  const {
    slots,
    slotProps,
    unstableStartFieldRef,
    unstableEndFieldRef,
    className
  } = forwardedProps, otherForwardedProps = _objectWithoutPropertiesLoose(forwardedProps, _excluded7);
  const ownerState = themeProps;
  const classes = useUtilityClasses4(ownerState);
  const Root = (slots == null ? void 0 : slots.root) ?? MultiInputDateTimeRangeFieldRoot;
  const rootProps = useSlotProps_default({
    elementType: Root,
    externalSlotProps: slotProps == null ? void 0 : slotProps.root,
    externalForwardedProps: otherForwardedProps,
    additionalProps: {
      ref
    },
    ownerState,
    className: clsx_default(className, classes.root)
  });
  const TextField = (slots == null ? void 0 : slots.textField) ?? (inProps.enableAccessibleFieldDOMStructure ? PickersTextField : TextField_default);
  const startTextFieldProps = useSlotProps_default({
    elementType: TextField,
    externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
    ownerState: _extends({}, ownerState, {
      position: "start"
    })
  });
  const endTextFieldProps = useSlotProps_default({
    elementType: TextField,
    externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
    ownerState: _extends({}, ownerState, {
      position: "end"
    })
  });
  const Separator = (slots == null ? void 0 : slots.separator) ?? MultiInputDateTimeRangeFieldSeparator;
  const separatorProps = useSlotProps_default({
    elementType: Separator,
    externalSlotProps: slotProps == null ? void 0 : slotProps.separator,
    additionalProps: {
      children: ` ${internalProps.dateSeparator ?? "–"} `
    },
    ownerState,
    className: classes.separator
  });
  const fieldResponse = useMultiInputDateTimeRangeField({
    sharedProps: internalProps,
    startTextFieldProps,
    endTextFieldProps,
    unstableStartFieldRef,
    unstableEndFieldRef
  });
  const startDateProps = convertFieldResponseIntoMuiTextFieldProps(fieldResponse.startDate);
  const endDateProps = convertFieldResponseIntoMuiTextFieldProps(fieldResponse.endDate);
  return (0, import_jsx_runtime6.jsxs)(Root, _extends({}, rootProps, {
    children: [(0, import_jsx_runtime6.jsx)(TextField, _extends({
      fullWidth: true
    }, startDateProps)), (0, import_jsx_runtime6.jsx)(Separator, _extends({}, separatorProps)), (0, import_jsx_runtime6.jsx)(TextField, _extends({
      fullWidth: true
    }, endDateProps))]
  }));
});
true ? MultiInputDateTimeRangeField.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default utils.is12HourCycleInCurrentLocale()
   */
  ampm: import_prop_types4.default.bool,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: import_prop_types4.default.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types4.default.object,
  className: import_prop_types4.default.string,
  component: import_prop_types4.default.elementType,
  /**
   * String displayed between the start and the end dates.
   * @default "–"
   */
  dateSeparator: import_prop_types4.default.string,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: import_prop_types4.default.arrayOf(import_prop_types4.default.object),
  /**
   * Defines the `flex-direction` style property.
   * It is applied for all screen sizes.
   * @default 'column'
   */
  direction: import_prop_types4.default.oneOfType([import_prop_types4.default.oneOf(["column-reverse", "column", "row-reverse", "row"]), import_prop_types4.default.arrayOf(import_prop_types4.default.oneOf(["column-reverse", "column", "row-reverse", "row"])), import_prop_types4.default.object]),
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: import_prop_types4.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types4.default.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: import_prop_types4.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types4.default.bool,
  /**
   * Add an element between each child.
   */
  divider: import_prop_types4.default.node,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: import_prop_types4.default.bool,
  /**
   * Format of the date when rendered in the input(s).
   */
  format: import_prop_types4.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types4.default.oneOf(["dense", "spacious"]),
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: import_prop_types4.default.object,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: import_prop_types4.default.object,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: import_prop_types4.default.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: import_prop_types4.default.object,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: import_prop_types4.default.object,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: import_prop_types4.default.object,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: import_prop_types4.default.number,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types4.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types4.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types4.default.func,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   * @default false
   */
  readOnly: import_prop_types4.default.bool,
  /**
   * The date used to generate a part of the new value that is not present in the format when both `value` and `defaultValue` are empty.
   * For example, on time fields it will be used to determine the date to set.
   * @default The closest valid date using the validation props, except callbacks such as `shouldDisableDate`. Value is rounded to the most granular section used.
   */
  referenceDate: import_prop_types4.default.object,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types4.default.oneOfType([import_prop_types4.default.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types4.default.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types4.default.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: import_prop_types4.default.func,
  /**
   * If `true`, the format will respect the leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `8/16/2018`)
   * If `false`, the format will always add leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `08/16/2018`)
   *
   * Warning n°1: Luxon is not able to respect the leading zeroes when using macro tokens (e.g: "DD"), so `shouldRespectLeadingZeros={true}` might lead to inconsistencies when using `AdapterLuxon`.
   *
   * Warning n°2: When `shouldRespectLeadingZeros={true}`, the field will add an invisible character on the sections containing a single digit to make sure `onChange` is fired.
   * If you need to get the clean value from the input, you can remove this character using `input.value.replace(/\u200e/g, '')`.
   *
   * Warning n°3: When used in strict mode, dayjs and moment require to respect the leading zeros.
   * This mean that when using `shouldRespectLeadingZeros={false}`, if you retrieve the value directly from the input (not listening to `onChange`) and your format contains tokens without leading zeros, the value will not be parsed by your library.
   *
   * @default false
   */
  shouldRespectLeadingZeros: import_prop_types4.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types4.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types4.default.object,
  /**
   * Defines the space between immediate children.
   * @default 0
   */
  spacing: import_prop_types4.default.oneOfType([import_prop_types4.default.arrayOf(import_prop_types4.default.oneOfType([import_prop_types4.default.number, import_prop_types4.default.string])), import_prop_types4.default.number, import_prop_types4.default.object, import_prop_types4.default.string]),
  style: import_prop_types4.default.object,
  /**
   * The system prop, which allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types4.default.oneOfType([import_prop_types4.default.arrayOf(import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object, import_prop_types4.default.bool])), import_prop_types4.default.func, import_prop_types4.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types4.default.string,
  unstableEndFieldRef: import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object]),
  unstableStartFieldRef: import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object]),
  /**
   * If `true`, the CSS flexbox `gap` is used instead of applying `margin` to children.
   *
   * While CSS `gap` removes the [known limitations](https://mui.com/joy-ui/react-stack/#limitations),
   * it is not fully supported in some browsers. We recommend checking https://caniuse.com/?search=flex%20gap before using this flag.
   *
   * To enable this flag globally, follow the [theme's default props](https://mui.com/material-ui/customization/theme-components/#default-props) configuration.
   * @default false
   */
  useFlexGap: import_prop_types4.default.bool,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types4.default.arrayOf(import_prop_types4.default.object)
} : void 0;

// node_modules/@mui/x-date-pickers-pro/SingleInputDateRangeField/SingleInputDateRangeField.js
init_extends();
init_objectWithoutPropertiesLoose();
var React11 = __toESM(require_react());
var import_prop_types5 = __toESM(require_prop_types());
init_useSlotProps();
init_esm();

// node_modules/@mui/x-date-pickers-pro/SingleInputDateRangeField/useSingleInputDateRangeField.js
var React10 = __toESM(require_react());
var useSingleInputDateRangeField = (inProps) => {
  const props = useDefaultizedDateField(inProps);
  const {
    forwardedProps,
    internalProps
  } = splitFieldInternalAndForwardedProps(props, "date");
  const fieldValueManager = React10.useMemo(() => getRangeFieldValueManager({
    dateSeparator: internalProps.dateSeparator
  }), [internalProps.dateSeparator]);
  return useField({
    forwardedProps,
    internalProps,
    valueManager: rangeValueManager,
    fieldValueManager,
    validator: validateDateRange,
    valueType: "date"
  });
};

// node_modules/@mui/x-date-pickers-pro/SingleInputDateRangeField/SingleInputDateRangeField.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var _excluded8 = ["slots", "slotProps", "InputProps", "inputProps"];
var SingleInputDateRangeField = React11.forwardRef(function SingleInputDateRangeField2(inProps, inRef) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiSingleInputDateRangeField"
  });
  const {
    slots,
    slotProps,
    InputProps,
    inputProps
  } = themeProps, other = _objectWithoutPropertiesLoose(themeProps, _excluded8);
  const ownerState = themeProps;
  const TextField = (slots == null ? void 0 : slots.textField) ?? (inProps.enableAccessibleFieldDOMStructure ? PickersTextField : TextField_default);
  const textFieldProps = useSlotProps_default({
    elementType: TextField,
    externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
    externalForwardedProps: other,
    ownerState,
    additionalProps: {
      ref: inRef
    }
  });
  textFieldProps.inputProps = _extends({}, inputProps, textFieldProps.inputProps);
  textFieldProps.InputProps = _extends({}, InputProps, textFieldProps.InputProps);
  const fieldResponse = useSingleInputDateRangeField(textFieldProps);
  const convertedFieldResponse = convertFieldResponseIntoMuiTextFieldProps(fieldResponse);
  const processedFieldProps = useClearableField(_extends({}, convertedFieldResponse, {
    slots,
    slotProps
  }));
  return (0, import_jsx_runtime7.jsx)(TextField, _extends({}, processedFieldProps));
});
SingleInputDateRangeField.fieldType = "single-input";
true ? SingleInputDateRangeField.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the `input` element is focused during the first mount.
   * @default false
   */
  autoFocus: import_prop_types5.default.bool,
  className: import_prop_types5.default.string,
  /**
   * If `true`, a clear button will be shown in the field allowing value clearing.
   * @default false
   */
  clearable: import_prop_types5.default.bool,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'primary'
   */
  color: import_prop_types5.default.oneOf(["error", "info", "primary", "secondary", "success", "warning"]),
  component: import_prop_types5.default.elementType,
  /**
   * String displayed between the start and the end dates.
   * @default "–"
   */
  dateSeparator: import_prop_types5.default.string,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: import_prop_types5.default.arrayOf(import_prop_types5.default.object),
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: import_prop_types5.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types5.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types5.default.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: import_prop_types5.default.bool,
  /**
   * If `true`, the component is displayed in focused state.
   */
  focused: import_prop_types5.default.bool,
  /**
   * Format of the date when rendered in the input(s).
   */
  format: import_prop_types5.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types5.default.oneOf(["dense", "spacious"]),
  /**
   * Props applied to the [`FormHelperText`](/material-ui/api/form-helper-text/) element.
   */
  FormHelperTextProps: import_prop_types5.default.object,
  /**
   * If `true`, the input will take up the full width of its container.
   * @default false
   */
  fullWidth: import_prop_types5.default.bool,
  /**
   * The helper text content.
   */
  helperText: import_prop_types5.default.node,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: import_prop_types5.default.bool,
  /**
   * The id of the `input` element.
   * Use this prop to make `label` and `helperText` accessible for screen readers.
   */
  id: import_prop_types5.default.string,
  /**
   * Props applied to the [`InputLabel`](/material-ui/api/input-label/) element.
   * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
   */
  InputLabelProps: import_prop_types5.default.object,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: import_prop_types5.default.object,
  /**
   * Props applied to the Input element.
   * It will be a [`FilledInput`](/material-ui/api/filled-input/),
   * [`OutlinedInput`](/material-ui/api/outlined-input/) or [`Input`](/material-ui/api/input/)
   * component depending on the `variant` prop value.
   */
  InputProps: import_prop_types5.default.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType_default,
  /**
   * The label content.
   */
  label: import_prop_types5.default.node,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: import_prop_types5.default.oneOf(["dense", "none", "normal"]),
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: import_prop_types5.default.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: import_prop_types5.default.object,
  /**
   * Name attribute of the `input` element.
   */
  name: import_prop_types5.default.string,
  onBlur: import_prop_types5.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types5.default.func,
  /**
   * Callback fired when the clear button is clicked.
   */
  onClear: import_prop_types5.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types5.default.func,
  onFocus: import_prop_types5.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types5.default.func,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   * @default false
   */
  readOnly: import_prop_types5.default.bool,
  /**
   * The date used to generate a part of the new value that is not present in the format when both `value` and `defaultValue` are empty.
   * For example, on time fields it will be used to determine the date to set.
   * @default The closest valid date using the validation props, except callbacks such as `shouldDisableDate`. Value is rounded to the most granular section used.
   */
  referenceDate: import_prop_types5.default.object,
  /**
   * If `true`, the label is displayed as required and the `input` element is required.
   * @default false
   */
  required: import_prop_types5.default.bool,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types5.default.oneOfType([import_prop_types5.default.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types5.default.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types5.default.func,
  /**
   * If `true`, the format will respect the leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `8/16/2018`)
   * If `false`, the format will always add leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `08/16/2018`)
   *
   * Warning n°1: Luxon is not able to respect the leading zeroes when using macro tokens (e.g: "DD"), so `shouldRespectLeadingZeros={true}` might lead to inconsistencies when using `AdapterLuxon`.
   *
   * Warning n°2: When `shouldRespectLeadingZeros={true}`, the field will add an invisible character on the sections containing a single digit to make sure `onChange` is fired.
   * If you need to get the clean value from the input, you can remove this character using `input.value.replace(/\u200e/g, '')`.
   *
   * Warning n°3: When used in strict mode, dayjs and moment require to respect the leading zeros.
   * This mean that when using `shouldRespectLeadingZeros={false}`, if you retrieve the value directly from the input (not listening to `onChange`) and your format contains tokens without leading zeros, the value will not be parsed by your library.
   *
   * @default false
   */
  shouldRespectLeadingZeros: import_prop_types5.default.bool,
  /**
   * The size of the component.
   */
  size: import_prop_types5.default.oneOf(["medium", "small"]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types5.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types5.default.object,
  style: import_prop_types5.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types5.default.oneOfType([import_prop_types5.default.arrayOf(import_prop_types5.default.oneOfType([import_prop_types5.default.func, import_prop_types5.default.object, import_prop_types5.default.bool])), import_prop_types5.default.func, import_prop_types5.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types5.default.string,
  /**
   * The ref object used to imperatively interact with the field.
   */
  unstableFieldRef: import_prop_types5.default.oneOfType([import_prop_types5.default.func, import_prop_types5.default.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types5.default.arrayOf(import_prop_types5.default.object),
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: import_prop_types5.default.oneOf(["filled", "outlined", "standard"])
} : void 0;

// node_modules/@mui/x-date-pickers-pro/SingleInputTimeRangeField/SingleInputTimeRangeField.js
init_extends();
init_objectWithoutPropertiesLoose();
var React13 = __toESM(require_react());
var import_prop_types6 = __toESM(require_prop_types());
init_useSlotProps();
init_esm();

// node_modules/@mui/x-date-pickers-pro/SingleInputTimeRangeField/useSingleInputTimeRangeField.js
var React12 = __toESM(require_react());
var useSingleInputTimeRangeField = (inProps) => {
  const props = useDefaultizedTimeField(inProps);
  const {
    forwardedProps,
    internalProps
  } = splitFieldInternalAndForwardedProps(props, "time");
  const fieldValueManager = React12.useMemo(() => getRangeFieldValueManager({
    dateSeparator: internalProps.dateSeparator
  }), [internalProps.dateSeparator]);
  return useField({
    forwardedProps,
    internalProps,
    valueManager: rangeValueManager,
    fieldValueManager,
    validator: validateTimeRange,
    valueType: "time"
  });
};

// node_modules/@mui/x-date-pickers-pro/SingleInputTimeRangeField/SingleInputTimeRangeField.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var _excluded9 = ["slots", "slotProps", "InputProps", "inputProps"];
var SingleInputTimeRangeField = React13.forwardRef(function SingleInputTimeRangeField2(inProps, inRef) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiSingleInputTimeRangeField"
  });
  const {
    slots,
    slotProps,
    InputProps,
    inputProps
  } = themeProps, other = _objectWithoutPropertiesLoose(themeProps, _excluded9);
  const ownerState = themeProps;
  const TextField = (slots == null ? void 0 : slots.textField) ?? (inProps.enableAccessibleFieldDOMStructure ? PickersTextField : TextField_default);
  const textFieldProps = useSlotProps_default({
    elementType: TextField,
    externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
    externalForwardedProps: other,
    ownerState,
    additionalProps: {
      ref: inRef
    }
  });
  textFieldProps.inputProps = _extends({}, inputProps, textFieldProps.inputProps);
  textFieldProps.InputProps = _extends({}, InputProps, textFieldProps.InputProps);
  const fieldResponse = useSingleInputTimeRangeField(textFieldProps);
  const convertedFieldResponse = convertFieldResponseIntoMuiTextFieldProps(fieldResponse);
  const processedFieldProps = useClearableField(_extends({}, convertedFieldResponse, {
    slots,
    slotProps
  }));
  return (0, import_jsx_runtime8.jsx)(TextField, _extends({}, processedFieldProps));
});
SingleInputTimeRangeField.fieldType = "single-input";
true ? SingleInputTimeRangeField.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default utils.is12HourCycleInCurrentLocale()
   */
  ampm: import_prop_types6.default.bool,
  /**
   * If `true`, the `input` element is focused during the first mount.
   * @default false
   */
  autoFocus: import_prop_types6.default.bool,
  className: import_prop_types6.default.string,
  /**
   * If `true`, a clear button will be shown in the field allowing value clearing.
   * @default false
   */
  clearable: import_prop_types6.default.bool,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'primary'
   */
  color: import_prop_types6.default.oneOf(["error", "info", "primary", "secondary", "success", "warning"]),
  component: import_prop_types6.default.elementType,
  /**
   * String displayed between the start and the end dates.
   * @default "–"
   */
  dateSeparator: import_prop_types6.default.string,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: import_prop_types6.default.arrayOf(import_prop_types6.default.object),
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: import_prop_types6.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types6.default.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: import_prop_types6.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types6.default.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: import_prop_types6.default.bool,
  /**
   * If `true`, the component is displayed in focused state.
   */
  focused: import_prop_types6.default.bool,
  /**
   * Format of the date when rendered in the input(s).
   */
  format: import_prop_types6.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types6.default.oneOf(["dense", "spacious"]),
  /**
   * Props applied to the [`FormHelperText`](/material-ui/api/form-helper-text/) element.
   */
  FormHelperTextProps: import_prop_types6.default.object,
  /**
   * If `true`, the input will take up the full width of its container.
   * @default false
   */
  fullWidth: import_prop_types6.default.bool,
  /**
   * The helper text content.
   */
  helperText: import_prop_types6.default.node,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: import_prop_types6.default.bool,
  /**
   * The id of the `input` element.
   * Use this prop to make `label` and `helperText` accessible for screen readers.
   */
  id: import_prop_types6.default.string,
  /**
   * Props applied to the [`InputLabel`](/material-ui/api/input-label/) element.
   * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
   */
  InputLabelProps: import_prop_types6.default.object,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: import_prop_types6.default.object,
  /**
   * Props applied to the Input element.
   * It will be a [`FilledInput`](/material-ui/api/filled-input/),
   * [`OutlinedInput`](/material-ui/api/outlined-input/) or [`Input`](/material-ui/api/input/)
   * component depending on the `variant` prop value.
   */
  InputProps: import_prop_types6.default.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType_default,
  /**
   * The label content.
   */
  label: import_prop_types6.default.node,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: import_prop_types6.default.oneOf(["dense", "none", "normal"]),
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: import_prop_types6.default.object,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: import_prop_types6.default.object,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: import_prop_types6.default.number,
  /**
   * Name attribute of the `input` element.
   */
  name: import_prop_types6.default.string,
  onBlur: import_prop_types6.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types6.default.func,
  /**
   * Callback fired when the clear button is clicked.
   */
  onClear: import_prop_types6.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types6.default.func,
  onFocus: import_prop_types6.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types6.default.func,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   * @default false
   */
  readOnly: import_prop_types6.default.bool,
  /**
   * The date used to generate a part of the new value that is not present in the format when both `value` and `defaultValue` are empty.
   * For example, on time fields it will be used to determine the date to set.
   * @default The closest valid date using the validation props, except callbacks such as `shouldDisableDate`. Value is rounded to the most granular section used.
   */
  referenceDate: import_prop_types6.default.object,
  /**
   * If `true`, the label is displayed as required and the `input` element is required.
   * @default false
   */
  required: import_prop_types6.default.bool,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types6.default.oneOfType([import_prop_types6.default.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types6.default.number]),
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: import_prop_types6.default.func,
  /**
   * If `true`, the format will respect the leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `8/16/2018`)
   * If `false`, the format will always add leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `08/16/2018`)
   *
   * Warning n°1: Luxon is not able to respect the leading zeroes when using macro tokens (e.g: "DD"), so `shouldRespectLeadingZeros={true}` might lead to inconsistencies when using `AdapterLuxon`.
   *
   * Warning n°2: When `shouldRespectLeadingZeros={true}`, the field will add an invisible character on the sections containing a single digit to make sure `onChange` is fired.
   * If you need to get the clean value from the input, you can remove this character using `input.value.replace(/\u200e/g, '')`.
   *
   * Warning n°3: When used in strict mode, dayjs and moment require to respect the leading zeros.
   * This mean that when using `shouldRespectLeadingZeros={false}`, if you retrieve the value directly from the input (not listening to `onChange`) and your format contains tokens without leading zeros, the value will not be parsed by your library.
   *
   * @default false
   */
  shouldRespectLeadingZeros: import_prop_types6.default.bool,
  /**
   * The size of the component.
   */
  size: import_prop_types6.default.oneOf(["medium", "small"]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types6.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types6.default.object,
  style: import_prop_types6.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types6.default.oneOfType([import_prop_types6.default.arrayOf(import_prop_types6.default.oneOfType([import_prop_types6.default.func, import_prop_types6.default.object, import_prop_types6.default.bool])), import_prop_types6.default.func, import_prop_types6.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types6.default.string,
  /**
   * The ref object used to imperatively interact with the field.
   */
  unstableFieldRef: import_prop_types6.default.oneOfType([import_prop_types6.default.func, import_prop_types6.default.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types6.default.arrayOf(import_prop_types6.default.object),
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: import_prop_types6.default.oneOf(["filled", "outlined", "standard"])
} : void 0;

// node_modules/@mui/x-date-pickers-pro/SingleInputDateTimeRangeField/SingleInputDateTimeRangeField.js
init_extends();
init_objectWithoutPropertiesLoose();
var React15 = __toESM(require_react());
var import_prop_types7 = __toESM(require_prop_types());
init_esm();
init_useSlotProps();

// node_modules/@mui/x-date-pickers-pro/SingleInputDateTimeRangeField/useSingleInputDateTimeRangeField.js
var React14 = __toESM(require_react());
var useSingleInputDateTimeRangeField = (inProps) => {
  const props = useDefaultizedDateTimeField(inProps);
  const {
    forwardedProps,
    internalProps
  } = splitFieldInternalAndForwardedProps(props, "date-time");
  const fieldValueManager = React14.useMemo(() => getRangeFieldValueManager({
    dateSeparator: internalProps.dateSeparator
  }), [internalProps.dateSeparator]);
  return useField({
    forwardedProps,
    internalProps,
    valueManager: rangeValueManager,
    fieldValueManager,
    validator: validateDateTimeRange,
    valueType: "date-time"
  });
};

// node_modules/@mui/x-date-pickers-pro/SingleInputDateTimeRangeField/SingleInputDateTimeRangeField.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var _excluded10 = ["slots", "slotProps", "InputProps", "inputProps"];
var SingleInputDateTimeRangeField = React15.forwardRef(function SingleInputDateTimeRangeField2(inProps, inRef) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiSingleInputDateTimeRangeField"
  });
  const {
    slots,
    slotProps,
    InputProps,
    inputProps
  } = themeProps, other = _objectWithoutPropertiesLoose(themeProps, _excluded10);
  const ownerState = themeProps;
  const TextField = (slots == null ? void 0 : slots.textField) ?? (inProps.enableAccessibleFieldDOMStructure ? PickersTextField : TextField_default);
  const textFieldProps = useSlotProps_default({
    elementType: TextField,
    externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
    externalForwardedProps: other,
    ownerState,
    additionalProps: {
      ref: inRef
    }
  });
  textFieldProps.inputProps = _extends({}, inputProps, textFieldProps.inputProps);
  textFieldProps.InputProps = _extends({}, InputProps, textFieldProps.InputProps);
  const fieldResponse = useSingleInputDateTimeRangeField(textFieldProps);
  const convertedFieldResponse = convertFieldResponseIntoMuiTextFieldProps(fieldResponse);
  const processedFieldProps = useClearableField(_extends({}, convertedFieldResponse, {
    slots,
    slotProps
  }));
  return (0, import_jsx_runtime9.jsx)(TextField, _extends({}, processedFieldProps));
});
SingleInputDateTimeRangeField.fieldType = "single-input";
true ? SingleInputDateTimeRangeField.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default utils.is12HourCycleInCurrentLocale()
   */
  ampm: import_prop_types7.default.bool,
  /**
   * If `true`, the `input` element is focused during the first mount.
   * @default false
   */
  autoFocus: import_prop_types7.default.bool,
  className: import_prop_types7.default.string,
  /**
   * If `true`, a clear button will be shown in the field allowing value clearing.
   * @default false
   */
  clearable: import_prop_types7.default.bool,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'primary'
   */
  color: import_prop_types7.default.oneOf(["error", "info", "primary", "secondary", "success", "warning"]),
  component: import_prop_types7.default.elementType,
  /**
   * String displayed between the start and the end dates.
   * @default "–"
   */
  dateSeparator: import_prop_types7.default.string,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: import_prop_types7.default.arrayOf(import_prop_types7.default.object),
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: import_prop_types7.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types7.default.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: import_prop_types7.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types7.default.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: import_prop_types7.default.bool,
  /**
   * If `true`, the component is displayed in focused state.
   */
  focused: import_prop_types7.default.bool,
  /**
   * Format of the date when rendered in the input(s).
   */
  format: import_prop_types7.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types7.default.oneOf(["dense", "spacious"]),
  /**
   * Props applied to the [`FormHelperText`](/material-ui/api/form-helper-text/) element.
   */
  FormHelperTextProps: import_prop_types7.default.object,
  /**
   * If `true`, the input will take up the full width of its container.
   * @default false
   */
  fullWidth: import_prop_types7.default.bool,
  /**
   * The helper text content.
   */
  helperText: import_prop_types7.default.node,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: import_prop_types7.default.bool,
  /**
   * The id of the `input` element.
   * Use this prop to make `label` and `helperText` accessible for screen readers.
   */
  id: import_prop_types7.default.string,
  /**
   * Props applied to the [`InputLabel`](/material-ui/api/input-label/) element.
   * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
   */
  InputLabelProps: import_prop_types7.default.object,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: import_prop_types7.default.object,
  /**
   * Props applied to the Input element.
   * It will be a [`FilledInput`](/material-ui/api/filled-input/),
   * [`OutlinedInput`](/material-ui/api/outlined-input/) or [`Input`](/material-ui/api/input/)
   * component depending on the `variant` prop value.
   */
  InputProps: import_prop_types7.default.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType_default,
  /**
   * The label content.
   */
  label: import_prop_types7.default.node,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: import_prop_types7.default.oneOf(["dense", "none", "normal"]),
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: import_prop_types7.default.object,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: import_prop_types7.default.object,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: import_prop_types7.default.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: import_prop_types7.default.object,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: import_prop_types7.default.object,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: import_prop_types7.default.object,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: import_prop_types7.default.number,
  /**
   * Name attribute of the `input` element.
   */
  name: import_prop_types7.default.string,
  onBlur: import_prop_types7.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types7.default.func,
  /**
   * Callback fired when the clear button is clicked.
   */
  onClear: import_prop_types7.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types7.default.func,
  onFocus: import_prop_types7.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types7.default.func,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   * @default false
   */
  readOnly: import_prop_types7.default.bool,
  /**
   * The date used to generate a part of the new value that is not present in the format when both `value` and `defaultValue` are empty.
   * For example, on time fields it will be used to determine the date to set.
   * @default The closest valid date using the validation props, except callbacks such as `shouldDisableDate`. Value is rounded to the most granular section used.
   */
  referenceDate: import_prop_types7.default.object,
  /**
   * If `true`, the label is displayed as required and the `input` element is required.
   * @default false
   */
  required: import_prop_types7.default.bool,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types7.default.oneOfType([import_prop_types7.default.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types7.default.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types7.default.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: import_prop_types7.default.func,
  /**
   * If `true`, the format will respect the leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `8/16/2018`)
   * If `false`, the format will always add leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `08/16/2018`)
   *
   * Warning n°1: Luxon is not able to respect the leading zeroes when using macro tokens (e.g: "DD"), so `shouldRespectLeadingZeros={true}` might lead to inconsistencies when using `AdapterLuxon`.
   *
   * Warning n°2: When `shouldRespectLeadingZeros={true}`, the field will add an invisible character on the sections containing a single digit to make sure `onChange` is fired.
   * If you need to get the clean value from the input, you can remove this character using `input.value.replace(/\u200e/g, '')`.
   *
   * Warning n°3: When used in strict mode, dayjs and moment require to respect the leading zeros.
   * This mean that when using `shouldRespectLeadingZeros={false}`, if you retrieve the value directly from the input (not listening to `onChange`) and your format contains tokens without leading zeros, the value will not be parsed by your library.
   *
   * @default false
   */
  shouldRespectLeadingZeros: import_prop_types7.default.bool,
  /**
   * The size of the component.
   */
  size: import_prop_types7.default.oneOf(["medium", "small"]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types7.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types7.default.object,
  style: import_prop_types7.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types7.default.oneOfType([import_prop_types7.default.arrayOf(import_prop_types7.default.oneOfType([import_prop_types7.default.func, import_prop_types7.default.object, import_prop_types7.default.bool])), import_prop_types7.default.func, import_prop_types7.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types7.default.string,
  /**
   * The ref object used to imperatively interact with the field.
   */
  unstableFieldRef: import_prop_types7.default.oneOfType([import_prop_types7.default.func, import_prop_types7.default.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types7.default.arrayOf(import_prop_types7.default.object),
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: import_prop_types7.default.oneOf(["filled", "outlined", "standard"])
} : void 0;

// node_modules/@mui/x-date-pickers-pro/DateRangeCalendar/DateRangeCalendar.js
init_objectWithoutPropertiesLoose();
init_extends();
var React18 = __toESM(require_react());
var import_prop_types9 = __toESM(require_prop_types());
init_clsx();
init_useEventCallback();
init_resolveComponentProps();
init_useSlotProps();
init_composeClasses();
init_useId();

// node_modules/@mui/x-date-pickers-pro/DateRangeCalendar/dateRangeCalendarClasses.js
init_esm();
var getDateRangeCalendarUtilityClass = (slot) => generateUtilityClass("MuiDateRangeCalendar", slot);
var dateRangeCalendarClasses = generateUtilityClasses("MuiDateRangeCalendar", ["root", "monthContainer", "dayDragging"]);

// node_modules/@mui/x-date-pickers-pro/internals/utils/date-range-manager.js
function calculateRangeChange({
  utils,
  range,
  newDate: selectedDate,
  rangePosition,
  allowRangeFlip = false,
  shouldMergeDateAndTime = false
}) {
  const [start, end] = range;
  if (shouldMergeDateAndTime && selectedDate) {
    if (start && rangePosition === "start") {
      selectedDate = mergeDateAndTime(utils, selectedDate, start);
    }
    if (end && rangePosition === "end") {
      selectedDate = mergeDateAndTime(utils, selectedDate, end);
    }
  }
  if (rangePosition === "start") {
    const truthyResult2 = allowRangeFlip ? {
      nextSelection: "start",
      newRange: [end, selectedDate]
    } : {
      nextSelection: "end",
      newRange: [selectedDate, null]
    };
    return Boolean(end) && utils.isAfter(selectedDate, end) ? truthyResult2 : {
      nextSelection: "end",
      newRange: [selectedDate, end]
    };
  }
  const truthyResult = allowRangeFlip ? {
    nextSelection: "end",
    newRange: [selectedDate, start]
  } : {
    nextSelection: "end",
    newRange: [selectedDate, null]
  };
  return Boolean(start) && utils.isBeforeDay(selectedDate, start) ? truthyResult : {
    nextSelection: "start",
    newRange: [start, selectedDate]
  };
}
function calculateRangePreview(options) {
  if (options.newDate == null) {
    return [null, null];
  }
  const [start, end] = options.range;
  const {
    newRange
  } = calculateRangeChange(options);
  if (!start || !end) {
    return newRange;
  }
  const [previewStart, previewEnd] = newRange;
  return options.rangePosition === "end" ? [end, previewEnd] : [previewStart, start];
}

// node_modules/@mui/x-date-pickers-pro/DateRangeCalendar/useDragRange.js
init_extends();
var React16 = __toESM(require_react());
init_useEventCallback();
var resolveDateFromTarget = (target, utils, timezone) => {
  const timestampString = target.dataset.timestamp;
  if (!timestampString) {
    return null;
  }
  const timestamp = +timestampString;
  return utils.date(new Date(timestamp).toISOString(), timezone);
};
var isSameAsDraggingDate = (event) => {
  const timestampString = event.target.dataset.timestamp;
  return timestampString === event.dataTransfer.getData("draggingDate");
};
var resolveButtonElement = (element) => {
  if (element) {
    if (element instanceof HTMLButtonElement && !element.disabled) {
      return element;
    }
    if (element.children.length) {
      return resolveButtonElement(element.children[0]);
    }
    return null;
  }
  return element;
};
var resolveElementFromTouch = (event, ignoreTouchTarget) => {
  var _a;
  if (((_a = event.changedTouches) == null ? void 0 : _a.length) === 1 && event.touches.length <= 1) {
    const element = document.elementFromPoint(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
    const buttonElement = resolveButtonElement(element);
    if (ignoreTouchTarget && buttonElement === event.changedTouches[0].target) {
      return null;
    }
    return buttonElement;
  }
  return null;
};
var useDragRangeEvents = ({
  utils,
  setRangeDragDay,
  setIsDragging,
  isDragging,
  onDatePositionChange,
  onDrop,
  disableDragEditing,
  dateRange,
  timezone
}) => {
  const emptyDragImgRef = React16.useRef(null);
  React16.useEffect(() => {
    emptyDragImgRef.current = document.createElement("img");
    emptyDragImgRef.current.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
  }, []);
  const isElementDraggable = (day) => {
    if (day == null) {
      return false;
    }
    const shouldInitDragging = !disableDragEditing && !!dateRange[0] && !!dateRange[1];
    const isSelectedStartDate = isStartOfRange(utils, day, dateRange);
    const isSelectedEndDate = isEndOfRange(utils, day, dateRange);
    return shouldInitDragging && (isSelectedStartDate || isSelectedEndDate);
  };
  const handleDragStart = useEventCallback_default((event) => {
    const newDate = resolveDateFromTarget(event.target, utils, timezone);
    if (!isElementDraggable(newDate)) {
      return;
    }
    event.stopPropagation();
    if (emptyDragImgRef.current) {
      event.dataTransfer.setDragImage(emptyDragImgRef.current, 0, 0);
    }
    setRangeDragDay(newDate);
    event.dataTransfer.effectAllowed = "move";
    setIsDragging(true);
    const buttonDataset = event.target.dataset;
    if (buttonDataset.timestamp) {
      event.dataTransfer.setData("draggingDate", buttonDataset.timestamp);
    }
    if (buttonDataset.position) {
      onDatePositionChange(buttonDataset.position);
    }
  });
  const handleTouchStart = useEventCallback_default((event) => {
    const target = resolveElementFromTouch(event);
    if (!target) {
      return;
    }
    const newDate = resolveDateFromTarget(target, utils, timezone);
    if (!isElementDraggable(newDate)) {
      return;
    }
    setRangeDragDay(newDate);
  });
  const handleDragEnter = useEventCallback_default((event) => {
    if (!isDragging) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    event.dataTransfer.dropEffect = "move";
    setRangeDragDay(resolveDateFromTarget(event.target, utils, timezone));
  });
  const handleTouchMove = useEventCallback_default((event) => {
    const target = resolveElementFromTouch(event);
    if (!target) {
      return;
    }
    const newDate = resolveDateFromTarget(target, utils, timezone);
    if (newDate) {
      setRangeDragDay(newDate);
    }
    const targetsAreIdentical = target === event.changedTouches[0].target;
    if (!targetsAreIdentical || !isElementDraggable(newDate)) {
      return;
    }
    setIsDragging(true);
    const button = event.target;
    const buttonDataset = button.dataset;
    if (buttonDataset.position) {
      onDatePositionChange(buttonDataset.position);
    }
  });
  const handleDragLeave = useEventCallback_default((event) => {
    if (!isDragging) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
  });
  const handleDragOver = useEventCallback_default((event) => {
    if (!isDragging) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    event.dataTransfer.dropEffect = "move";
  });
  const handleTouchEnd = useEventCallback_default((event) => {
    if (!isDragging) {
      return;
    }
    setRangeDragDay(null);
    setIsDragging(false);
    const target = resolveElementFromTouch(event, true);
    if (!target) {
      return;
    }
    target.focus();
    const newDate = resolveDateFromTarget(target, utils, timezone);
    if (newDate) {
      onDrop(newDate);
    }
  });
  const handleDragEnd = useEventCallback_default((event) => {
    if (!isDragging) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    setIsDragging(false);
    setRangeDragDay(null);
  });
  const handleDrop = useEventCallback_default((event) => {
    if (!isDragging) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    setIsDragging(false);
    setRangeDragDay(null);
    event.currentTarget.focus();
    if (isSameAsDraggingDate(event)) {
      return;
    }
    const newDate = resolveDateFromTarget(event.target, utils, timezone);
    if (newDate) {
      onDrop(newDate);
    }
  });
  return {
    onDragStart: handleDragStart,
    onDragEnter: handleDragEnter,
    onDragLeave: handleDragLeave,
    onDragOver: handleDragOver,
    onDragEnd: handleDragEnd,
    onDrop: handleDrop,
    onTouchStart: handleTouchStart,
    onTouchMove: handleTouchMove,
    onTouchEnd: handleTouchEnd
  };
};
var useDragRange = ({
  disableDragEditing,
  utils,
  onDatePositionChange,
  onDrop,
  dateRange,
  timezone
}) => {
  const [isDragging, setIsDragging] = React16.useState(false);
  const [rangeDragDay, setRangeDragDay] = React16.useState(null);
  const handleRangeDragDayChange = useEventCallback_default((val) => {
    if (!utils.isEqual(val, rangeDragDay)) {
      setRangeDragDay(val);
    }
  });
  const draggingDatePosition = React16.useMemo(() => {
    const [start, end] = dateRange;
    if (rangeDragDay) {
      if (start && utils.isBefore(rangeDragDay, start)) {
        return "start";
      }
      if (end && utils.isAfter(rangeDragDay, end)) {
        return "end";
      }
    }
    return null;
  }, [dateRange, rangeDragDay, utils]);
  const dragRangeEvents = useDragRangeEvents({
    utils,
    onDatePositionChange,
    onDrop,
    setIsDragging,
    isDragging,
    setRangeDragDay: handleRangeDragDayChange,
    disableDragEditing,
    dateRange,
    timezone
  });
  return React16.useMemo(() => _extends({
    isDragging,
    rangeDragDay,
    draggingDatePosition
  }, !disableDragEditing ? dragRangeEvents : {}), [isDragging, rangeDragDay, draggingDatePosition, disableDragEditing, dragRangeEvents]);
};

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useRangePosition.js
init_useControlled();
init_useEventCallback();
var useRangePosition = (props, singleInputFieldRef) => {
  const [rangePosition, setRangePosition] = useControlled({
    name: "useRangePosition",
    state: "rangePosition",
    controlled: props.rangePosition,
    default: props.defaultRangePosition ?? "start"
  });
  const syncRangePositionWithSingleInputField = (newRangePosition) => {
    if ((singleInputFieldRef == null ? void 0 : singleInputFieldRef.current) == null) {
      return;
    }
    const sections = singleInputFieldRef.current.getSections();
    const targetActiveSectionIndex = newRangePosition === "start" ? 0 : sections.length / 2;
    singleInputFieldRef.current.setSelectedSections(targetActiveSectionIndex);
  };
  const handleRangePositionChange = useEventCallback_default((newRangePosition) => {
    var _a;
    setRangePosition(newRangePosition);
    (_a = props.onRangePositionChange) == null ? void 0 : _a.call(props, newRangePosition);
    syncRangePositionWithSingleInputField(newRangePosition);
  });
  return {
    rangePosition,
    onRangePositionChange: handleRangePositionChange
  };
};

// node_modules/@mui/x-date-pickers-pro/internals/constants/dimensions.js
var DAY_RANGE_SIZE = 40;
var RANGE_VIEW_HEIGHT = VIEW_HEIGHT + 6 * 2 * DAY_MARGIN;

// node_modules/@mui/x-date-pickers-pro/PickersRangeCalendarHeader/PickersRangeCalendarHeader.js
init_extends();
init_objectWithoutPropertiesLoose();
var React17 = __toESM(require_react());
var import_prop_types8 = __toESM(require_prop_types());
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var _excluded11 = ["calendars", "month", "monthIndex", "labelId"];
var _excluded22 = ["format", "slots", "slotProps", "currentMonth", "onMonthChange", "disableFuture", "disablePast", "minDate", "maxDate", "timezone", "reduceAnimations", "views", "view"];
var PickersRangeCalendarHeaderContentMultipleCalendars = styled_default(PickersArrowSwitcher)({
  padding: "12px 16px 4px 16px",
  display: "flex",
  alignItems: "center",
  justifyContent: "space-between"
});
var PickersRangeCalendarHeader = React17.forwardRef(function PickersRangeCalendarHeader2(props, ref) {
  const utils = useUtils();
  const translations = usePickersTranslations();
  const {
    calendars,
    month,
    monthIndex,
    labelId
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded11);
  const {
    format,
    slots,
    slotProps,
    currentMonth,
    onMonthChange,
    disableFuture,
    disablePast,
    minDate,
    maxDate,
    timezone
    // omit props that are not used in the PickersArrowSwitcher
  } = other, otherRangeProps = _objectWithoutPropertiesLoose(other, _excluded22);
  const isNextMonthDisabled = useNextMonthDisabled(currentMonth, {
    disableFuture,
    maxDate,
    timezone
  });
  const isPreviousMonthDisabled = usePreviousMonthDisabled(currentMonth, {
    disablePast,
    minDate,
    timezone
  });
  if (calendars === 1) {
    return (0, import_jsx_runtime10.jsx)(PickersCalendarHeader, _extends({}, other, {
      labelId,
      ref
    }));
  }
  const selectNextMonth = () => onMonthChange(utils.addMonths(currentMonth, 1), "left");
  const selectPreviousMonth = () => onMonthChange(utils.addMonths(currentMonth, -1), "right");
  return (0, import_jsx_runtime10.jsx)(PickersRangeCalendarHeaderContentMultipleCalendars, _extends({}, otherRangeProps, {
    ref,
    onGoToPrevious: selectPreviousMonth,
    onGoToNext: selectNextMonth,
    isPreviousHidden: monthIndex !== 0,
    isPreviousDisabled: isPreviousMonthDisabled,
    previousLabel: translations.previousMonth,
    isNextHidden: monthIndex !== calendars - 1,
    isNextDisabled: isNextMonthDisabled,
    nextLabel: translations.nextMonth,
    slots,
    slotProps,
    labelId,
    children: utils.formatByString(month, format ?? `${utils.formats.month} ${utils.formats.year}`)
  }));
});
true ? PickersRangeCalendarHeader.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The number of calendars rendered.
   */
  calendars: import_prop_types8.default.oneOf([1, 2, 3]).isRequired,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types8.default.object,
  className: import_prop_types8.default.string,
  currentMonth: import_prop_types8.default.object.isRequired,
  disabled: import_prop_types8.default.bool,
  disableFuture: import_prop_types8.default.bool,
  disablePast: import_prop_types8.default.bool,
  /**
   * Format used to display the date.
   * @default `${adapter.formats.month} ${adapter.formats.year}`
   */
  format: import_prop_types8.default.string,
  /**
   * Id of the calendar text element.
   * It is used to establish an `aria-labelledby` relationship with the calendar `grid` element.
   */
  labelId: import_prop_types8.default.string,
  maxDate: import_prop_types8.default.object.isRequired,
  minDate: import_prop_types8.default.object.isRequired,
  /**
   * Month used for this header.
   */
  month: import_prop_types8.default.object.isRequired,
  /**
   * Index of the month used for this header.
   */
  monthIndex: import_prop_types8.default.number.isRequired,
  onMonthChange: import_prop_types8.default.func.isRequired,
  onViewChange: import_prop_types8.default.func,
  reduceAnimations: import_prop_types8.default.bool.isRequired,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types8.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types8.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types8.default.oneOfType([import_prop_types8.default.arrayOf(import_prop_types8.default.oneOfType([import_prop_types8.default.func, import_prop_types8.default.object, import_prop_types8.default.bool])), import_prop_types8.default.func, import_prop_types8.default.object]),
  timezone: import_prop_types8.default.string.isRequired,
  view: import_prop_types8.default.oneOf(["day", "month", "year"]).isRequired,
  views: import_prop_types8.default.arrayOf(import_prop_types8.default.oneOf(["day", "month", "year"]).isRequired).isRequired
} : void 0;

// node_modules/@mui/x-date-pickers-pro/DateRangeCalendar/DateRangeCalendar.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var _excluded12 = ["value", "defaultValue", "referenceDate", "onChange", "className", "disableFuture", "disablePast", "minDate", "maxDate", "shouldDisableDate", "reduceAnimations", "onMonthChange", "rangePosition", "defaultRangePosition", "onRangePositionChange", "calendars", "currentMonthCalendarPosition", "slots", "slotProps", "loading", "renderLoading", "disableHighlightToday", "readOnly", "disabled", "showDaysOutsideCurrentMonth", "dayOfWeekFormatter", "disableAutoMonthSwitching", "autoFocus", "fixedWeekNumber", "disableDragEditing", "displayWeekNumber", "timezone", "availableRangePositions", "views", "view", "openTo", "onViewChange"];
var _excluded23 = ["isDragging", "rangeDragDay", "draggingDatePosition"];
var releaseInfo2 = getReleaseInfo();
var DateRangeCalendarRoot = styled_default("div", {
  name: "MuiDateRangeCalendar",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})({
  display: "flex",
  flexDirection: "row"
});
var DateRangeCalendarMonthContainer = styled_default("div", {
  name: "MuiDateRangeCalendar",
  slot: "Container",
  overridesResolver: (_, styles) => styles.monthContainer
})(({
  theme
}) => ({
  "&:not(:last-of-type)": {
    borderRight: `1px solid ${(theme.vars || theme).palette.divider}`
  }
}));
var weeksContainerHeight = (DAY_RANGE_SIZE + DAY_MARGIN * 2) * 6;
var DayCalendarForRange = styled_default(DayCalendar)(({
  theme
}) => ({
  minWidth: 312,
  minHeight: weeksContainerHeight,
  [`&.${dateRangeCalendarClasses.dayDragging}`]: {
    [`& .${dateRangePickerDayClasses.day}`]: {
      cursor: "grabbing"
    },
    [`& .${dateRangePickerDayClasses.root}:not(.${dateRangePickerDayClasses.rangeIntervalDayHighlightStart}):not(.${dateRangePickerDayClasses.rangeIntervalDayHighlightEnd}) .${dateRangePickerDayClasses.day}:not(.${dateRangePickerDayClasses.notSelectedDate})`]: {
      // we can't override `PickersDay` background color here, because it's styles take precedence
      opacity: 0.6
    }
  },
  [`&:not(.${dateRangeCalendarClasses.dayDragging}) .${dateRangePickerDayClasses.dayOutsideRangeInterval}`]: {
    "@media (pointer: fine)": {
      "&:hover": {
        border: `1px solid ${(theme.vars || theme).palette.grey[500]}`
      }
    }
  }
}));
function useDateRangeCalendarDefaultizedProps(props, name) {
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const defaultReduceAnimations = useDefaultReduceAnimations();
  const themeProps = useThemeProps({
    props,
    name
  });
  return _extends({}, themeProps, {
    renderLoading: themeProps.renderLoading ?? (() => (0, import_jsx_runtime11.jsx)("span", {
      children: "..."
    })),
    reduceAnimations: themeProps.reduceAnimations ?? defaultReduceAnimations,
    loading: props.loading ?? false,
    disablePast: props.disablePast ?? false,
    disableFuture: props.disableFuture ?? false,
    openTo: themeProps.openTo ?? "day",
    views: themeProps.views ?? ["day"],
    minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate),
    calendars: themeProps.calendars ?? 2,
    disableDragEditing: themeProps.disableDragEditing ?? false,
    availableRangePositions: themeProps.availableRangePositions ?? ["start", "end"]
  });
}
var useUtilityClasses5 = (ownerState) => {
  const {
    classes,
    isDragging
  } = ownerState;
  const slots = {
    root: ["root"],
    monthContainer: ["monthContainer"],
    dayCalendar: [isDragging && "dayDragging"]
  };
  return composeClasses(slots, getDateRangeCalendarUtilityClass, classes);
};
var DateRangeCalendar = React18.forwardRef(function DateRangeCalendar2(inProps, ref) {
  const props = useDateRangeCalendarDefaultizedProps(inProps, "MuiDateRangeCalendar");
  const shouldHavePreview = useMediaQuery(DEFAULT_DESKTOP_MODE_MEDIA_QUERY, {
    defaultMatches: false
  });
  const {
    value: valueProp,
    defaultValue,
    referenceDate,
    onChange,
    className,
    disableFuture,
    disablePast,
    minDate,
    maxDate,
    shouldDisableDate,
    reduceAnimations,
    onMonthChange,
    rangePosition: rangePositionProp,
    defaultRangePosition: inDefaultRangePosition,
    onRangePositionChange: inOnRangePositionChange,
    calendars,
    currentMonthCalendarPosition = 1,
    slots,
    slotProps,
    loading,
    renderLoading,
    disableHighlightToday,
    readOnly,
    disabled,
    showDaysOutsideCurrentMonth,
    dayOfWeekFormatter,
    disableAutoMonthSwitching,
    autoFocus,
    fixedWeekNumber,
    disableDragEditing,
    displayWeekNumber,
    timezone: timezoneProp,
    availableRangePositions,
    views,
    view: inView,
    openTo,
    onViewChange
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded12);
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "DateRangeCalendar",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: rangeValueManager
  });
  const {
    setValueAndGoToNextView,
    view
  } = useViews({
    view: inView,
    views,
    openTo,
    onChange: handleValueChange,
    onViewChange,
    autoFocus
  });
  const utils = useUtils();
  const now = useNow(timezone);
  const id = useId();
  const {
    rangePosition,
    onRangePositionChange
  } = useRangePosition({
    rangePosition: rangePositionProp,
    defaultRangePosition: inDefaultRangePosition,
    onRangePositionChange: inOnRangePositionChange
  });
  const handleDatePositionChange = useEventCallback_default((position) => {
    if (rangePosition !== position) {
      onRangePositionChange(position);
    }
  });
  const handleSelectedDayChange = useEventCallback_default((newDate, selectionState, allowRangeFlip = false) => {
    const {
      nextSelection,
      newRange
    } = calculateRangeChange({
      newDate,
      utils,
      range: value,
      rangePosition,
      allowRangeFlip,
      shouldMergeDateAndTime: true
    });
    const isNextSectionAvailable = availableRangePositions.includes(nextSelection);
    if (isNextSectionAvailable) {
      onRangePositionChange(nextSelection);
    }
    const isFullRangeSelected = rangePosition === "end" && isRangeValid(utils, newRange);
    setValueAndGoToNextView(newRange, isFullRangeSelected || !isNextSectionAvailable ? "finish" : "partial", view);
  });
  const handleDrop = useEventCallback_default((newDate) => {
    handleSelectedDayChange(newDate, void 0, true);
  });
  const shouldDisableDragEditing = disableDragEditing || disabled || readOnly;
  const valueDayRange = React18.useMemo(() => [value[0] == null || !utils.isValid(value[0]) ? value[0] : utils.startOfDay(value[0]), value[1] == null || !utils.isValid(value[1]) ? value[1] : utils.endOfDay(value[1])], [value, utils]);
  const _useDragRange = useDragRange({
    disableDragEditing: shouldDisableDragEditing,
    onDrop: handleDrop,
    onDatePositionChange: handleDatePositionChange,
    utils,
    dateRange: valueDayRange,
    timezone
  }), {
    isDragging,
    rangeDragDay,
    draggingDatePosition
  } = _useDragRange, dragEventHandlers = _objectWithoutPropertiesLoose(_useDragRange, _excluded23);
  const ownerState = _extends({}, props, {
    isDragging
  });
  const classes = useUtilityClasses5(ownerState);
  const draggingRange = React18.useMemo(() => {
    if (!valueDayRange[0] || !valueDayRange[1] || !rangeDragDay) {
      return [null, null];
    }
    const newRange = calculateRangeChange({
      utils,
      range: valueDayRange,
      newDate: rangeDragDay,
      rangePosition,
      allowRangeFlip: true
    }).newRange;
    return newRange[0] !== null && newRange[1] !== null ? [utils.startOfDay(newRange[0]), utils.endOfDay(newRange[1])] : newRange;
  }, [rangePosition, rangeDragDay, utils, valueDayRange]);
  const wrappedShouldDisableDate = React18.useMemo(() => {
    if (!shouldDisableDate) {
      return void 0;
    }
    return (dayToTest) => shouldDisableDate(dayToTest, draggingDatePosition || rangePosition);
  }, [shouldDisableDate, rangePosition, draggingDatePosition]);
  const {
    calendarState,
    changeFocusedDay,
    changeMonth,
    handleChangeMonth,
    onMonthSwitchingAnimationEnd
  } = useCalendarState({
    value: value[0] || value[1],
    referenceDate,
    disableFuture,
    disablePast,
    disableSwitchToMonthOnDayFocus: true,
    maxDate,
    minDate,
    onMonthChange,
    reduceAnimations,
    shouldDisableDate: wrappedShouldDisableDate,
    timezone
  });
  const CalendarHeader = (slots == null ? void 0 : slots.calendarHeader) ?? PickersRangeCalendarHeader;
  const calendarHeaderProps = useSlotProps_default({
    elementType: CalendarHeader,
    externalSlotProps: slotProps == null ? void 0 : slotProps.calendarHeader,
    additionalProps: {
      calendars,
      views: ["day"],
      view: "day",
      currentMonth: calendarState.currentMonth,
      onMonthChange: (newMonth, direction) => handleChangeMonth({
        newMonth,
        direction
      }),
      minDate,
      maxDate,
      disabled,
      disablePast,
      disableFuture,
      reduceAnimations,
      timezone,
      slots,
      slotProps
    },
    ownerState: props
  });
  const prevValue = React18.useRef(null);
  React18.useEffect(() => {
    var _a, _b;
    const date = rangePosition === "start" ? value[0] : value[1];
    if (!date || !utils.isValid(date)) {
      return;
    }
    const prevDate = rangePosition === "start" ? (_a = prevValue.current) == null ? void 0 : _a[0] : (_b = prevValue.current) == null ? void 0 : _b[1];
    prevValue.current = value;
    if (disableAutoMonthSwitching && prevDate && utils.isEqual(prevDate, date)) {
      return;
    }
    const displayingMonthRange = calendars - 1;
    const currentMonthNumber = utils.getMonth(calendarState.currentMonth);
    const requestedMonthNumber = utils.getMonth(date);
    if (!utils.isSameYear(calendarState.currentMonth, date) || requestedMonthNumber < currentMonthNumber || requestedMonthNumber > currentMonthNumber + displayingMonthRange) {
      const newMonth = rangePosition === "start" ? date : (
        // If need to focus end, scroll to the state when "end" is displaying in the last calendar
        utils.addMonths(date, -displayingMonthRange)
      );
      changeMonth(newMonth);
    }
  }, [rangePosition, value]);
  const baseDateValidationProps = {
    disablePast,
    disableFuture,
    maxDate,
    minDate
  };
  const commonViewProps = {
    disableHighlightToday,
    readOnly,
    disabled
  };
  const [rangePreviewDay, setRangePreviewDay] = React18.useState(null);
  const CalendarTransitionProps = React18.useMemo(() => ({
    onMouseLeave: () => setRangePreviewDay(null)
  }), []);
  const previewingRange = calculateRangePreview({
    utils,
    range: valueDayRange,
    newDate: rangePreviewDay,
    rangePosition
  });
  const handleDayMouseEnter = useEventCallback_default((event, newPreviewRequest) => {
    if (!isWithinRange(utils, newPreviewRequest, valueDayRange)) {
      setRangePreviewDay(newPreviewRequest);
    } else {
      setRangePreviewDay(null);
    }
  });
  const slotsForDayCalendar = _extends({
    day: DateRangePickerDay2
  }, slots);
  const slotPropsForDayCalendar = _extends({}, slotProps, {
    day: (dayOwnerState) => {
      const {
        day
      } = dayOwnerState;
      const isSelectedStartDate = isStartOfRange(utils, day, valueDayRange);
      const isSelectedEndDate = isEndOfRange(utils, day, valueDayRange);
      const shouldInitDragging = !shouldDisableDragEditing && valueDayRange[0] && valueDayRange[1];
      const isElementDraggable = shouldInitDragging && (isSelectedStartDate || isSelectedEndDate);
      let datePosition;
      if (isSelectedStartDate) {
        datePosition = "start";
      } else if (isSelectedEndDate) {
        datePosition = "end";
      }
      const isStartOfHighlighting = isDragging ? isStartOfRange(utils, day, draggingRange) : isSelectedStartDate;
      const isEndOfHighlighting = isDragging ? isEndOfRange(utils, day, draggingRange) : isSelectedEndDate;
      return _extends({
        isPreviewing: shouldHavePreview ? isWithinRange(utils, day, previewingRange) : false,
        isStartOfPreviewing: shouldHavePreview ? isStartOfRange(utils, day, previewingRange) : false,
        isEndOfPreviewing: shouldHavePreview ? isEndOfRange(utils, day, previewingRange) : false,
        isHighlighting: isWithinRange(utils, day, isDragging ? draggingRange : valueDayRange),
        isStartOfHighlighting,
        isEndOfHighlighting: isDragging ? isEndOfRange(utils, day, draggingRange) : isSelectedEndDate,
        onMouseEnter: shouldHavePreview ? handleDayMouseEnter : void 0,
        // apply selected styling to the dragging start or end day
        isVisuallySelected: dayOwnerState.selected || isDragging && (isStartOfHighlighting || isEndOfHighlighting),
        "data-position": datePosition
      }, dragEventHandlers, {
        draggable: isElementDraggable ? true : void 0
      }, resolveComponentProps_default(slotProps == null ? void 0 : slotProps.day, dayOwnerState) ?? {});
    }
  });
  const calendarMonths = React18.useMemo(() => Array.from({
    length: calendars
  }).map((_, index) => index), [calendars]);
  const visibleMonths = React18.useMemo(() => {
    if (true) {
      if (currentMonthCalendarPosition > calendars || currentMonthCalendarPosition < 1) {
        warnOnce(["MUI X: The `currentMonthCalendarPosition` prop must be an integer between `1` and the amount of calendars rendered.", "For example if you have 2 calendars rendered, it should be equal to either 1 or 2."]);
      }
    }
    const firstMonth = utils.addMonths(calendarState.currentMonth, 1 - currentMonthCalendarPosition);
    return Array.from({
      length: calendars
    }).map((_, index) => utils.addMonths(firstMonth, index));
  }, [utils, calendarState.currentMonth, calendars, currentMonthCalendarPosition]);
  const focusedMonth = React18.useMemo(() => {
    if (!autoFocus) {
      return null;
    }
    if (value[0] != null) {
      return visibleMonths.find((month) => utils.isSameMonth(month, value[0]));
    }
    if (value[1] != null) {
      return visibleMonths.find((month) => utils.isSameMonth(month, value[1]));
    }
    return visibleMonths.find((month) => utils.isSameMonth(month, now)) ?? visibleMonths[0];
  }, [utils, value, visibleMonths, autoFocus, now]);
  return (0, import_jsx_runtime11.jsxs)(DateRangeCalendarRoot, _extends({
    ref,
    className: clsx_default(className, classes.root),
    ownerState
  }, other, {
    children: [(0, import_jsx_runtime11.jsx)(Watermark, {
      packageName: "x-date-pickers-pro",
      releaseInfo: releaseInfo2
    }), calendarMonths.map((monthIndex) => {
      const month = visibleMonths[monthIndex];
      const labelId = `${id}-grid-${monthIndex}-label`;
      return (0, import_jsx_runtime11.jsxs)(DateRangeCalendarMonthContainer, {
        className: classes.monthContainer,
        children: [(0, import_jsx_runtime11.jsx)(CalendarHeader, _extends({}, calendarHeaderProps, {
          month,
          monthIndex,
          labelId
        })), (0, import_jsx_runtime11.jsx)(DayCalendarForRange, _extends({
          className: classes.dayCalendar
        }, calendarState, baseDateValidationProps, commonViewProps, {
          onMonthSwitchingAnimationEnd,
          onFocusedDayChange: changeFocusedDay,
          reduceAnimations,
          selectedDays: value,
          onSelectedDaysChange: handleSelectedDayChange,
          currentMonth: month,
          TransitionProps: CalendarTransitionProps,
          shouldDisableDate: wrappedShouldDisableDate,
          showDaysOutsideCurrentMonth: calendars === 1 && showDaysOutsideCurrentMonth,
          dayOfWeekFormatter,
          loading,
          renderLoading,
          slots: slotsForDayCalendar,
          slotProps: slotPropsForDayCalendar,
          autoFocus: month === focusedMonth,
          fixedWeekNumber,
          displayWeekNumber,
          timezone,
          gridLabelId: labelId
        }))]
      }, monthIndex);
    })]
  }));
});
true ? DateRangeCalendar.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types9.default.bool,
  /**
   * Range positions available for selection.
   * This list is checked against when checking if a next range position can be selected.
   *
   * Used on Date Time Range pickers with current `rangePosition` to force a `finish` selection after just one range position selection.
   * @default ['start', 'end']
   */
  availableRangePositions: import_prop_types9.default.arrayOf(import_prop_types9.default.oneOf(["end", "start"]).isRequired),
  /**
   * The number of calendars to render.
   * @default 2
   */
  calendars: import_prop_types9.default.oneOf([1, 2, 3]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types9.default.object,
  className: import_prop_types9.default.string,
  /**
   * Position the current month is rendered in.
   * @default 1
   */
  currentMonthCalendarPosition: import_prop_types9.default.oneOf([1, 2, 3]),
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: import_prop_types9.default.func,
  /**
   * The initial position in the edited date range.
   * Used when the component is not controlled.
   * @default 'start'
   */
  defaultRangePosition: import_prop_types9.default.oneOf(["end", "start"]),
  /**
   * The default selected value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types9.default.arrayOf(import_prop_types9.default.object),
  /**
   * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
   * @default false
   */
  disableAutoMonthSwitching: import_prop_types9.default.bool,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types9.default.bool,
  /**
   * If `true`, editing dates by dragging is disabled.
   * @default false
   */
  disableDragEditing: import_prop_types9.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types9.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types9.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types9.default.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: import_prop_types9.default.bool,
  /**
   * The day view will show as many weeks as needed after the end of the current month to match this value.
   * Put it to 6 to have a fixed number of weeks in Gregorian calendars
   */
  fixedWeekNumber: import_prop_types9.default.number,
  /**
   * Controlled focused view.
   */
  focusedView: import_prop_types9.default.oneOf(["day"]),
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: import_prop_types9.default.bool,
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: import_prop_types9.default.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: import_prop_types9.default.object,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TView The view type. Will be one of date or time views.
   * @param {TValue} value The new value.
   * @param {PickerSelectionState | undefined} selectionState Indicates if the date selection is complete.
   * @param {TView | undefined} selectedView Indicates the view in which the selection has been made.
   */
  onChange: import_prop_types9.default.func,
  /**
   * Callback fired on focused view change.
   * @template TView
   * @param {TView} view The new view to focus or not.
   * @param {boolean} hasFocus `true` if the view should be focused.
   */
  onFocusedViewChange: import_prop_types9.default.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: import_prop_types9.default.func,
  /**
   * Callback fired when the range position changes.
   * @param {RangePosition} rangePosition The new range position.
   */
  onRangePositionChange: import_prop_types9.default.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: import_prop_types9.default.func,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: import_prop_types9.default.oneOf(["day"]),
  /**
   * The position in the currently edited date range.
   * Used when the component position is controlled.
   */
  rangePosition: import_prop_types9.default.oneOf(["end", "start"]),
  /**
   * Make picker read only.
   * @default false
   */
  readOnly: import_prop_types9.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types9.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date using the validation props, except callbacks such as `shouldDisableDate`.
   */
  referenceDate: import_prop_types9.default.object,
  /**
   * Component rendered on the "day" view when `props.loading` is true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => "..."
   */
  renderLoading: import_prop_types9.default.func,
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types9.default.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types9.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types9.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types9.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types9.default.oneOfType([import_prop_types9.default.arrayOf(import_prop_types9.default.oneOfType([import_prop_types9.default.func, import_prop_types9.default.object, import_prop_types9.default.bool])), import_prop_types9.default.func, import_prop_types9.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types9.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types9.default.arrayOf(import_prop_types9.default.object),
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: import_prop_types9.default.oneOf(["day"]),
  /**
   * Available views.
   */
  views: import_prop_types9.default.arrayOf(import_prop_types9.default.oneOf(["day"]))
} : void 0;

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/DateRangePicker.js
init_extends();
init_objectWithoutPropertiesLoose();
var React27 = __toESM(require_react());
var import_prop_types13 = __toESM(require_prop_types());
init_esm();

// node_modules/@mui/x-date-pickers-pro/DesktopDateRangePicker/DesktopDateRangePicker.js
init_extends();
var React24 = __toESM(require_react());
var import_prop_types11 = __toESM(require_prop_types());
init_resolveComponentProps();
init_esm();

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/shared.js
init_extends();
var React20 = __toESM(require_react());

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/DateRangePickerToolbar.js
init_extends();
init_objectWithoutPropertiesLoose();
var React19 = __toESM(require_react());
var import_prop_types10 = __toESM(require_prop_types());
init_clsx();
init_composeClasses();

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/dateRangePickerToolbarClasses.js
init_esm();
function getDateRangePickerToolbarUtilityClass(slot) {
  return generateUtilityClass("MuiDateRangePickerToolbar", slot);
}
var dateRangePickerToolbarClasses = generateUtilityClasses("MuiDateRangePickerToolbar", ["root", "container"]);

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/DateRangePickerToolbar.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var _excluded13 = ["value", "rangePosition", "onRangePositionChange", "toolbarFormat", "className", "onViewChange", "view", "views"];
var useUtilityClasses6 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    container: ["container"]
  };
  return composeClasses(slots, getDateRangePickerToolbarUtilityClass, classes);
};
var DateRangePickerToolbarRoot = styled_default(PickersToolbar, {
  name: "MuiDateRangePickerToolbar",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})({});
var DateRangePickerToolbarContainer = styled_default("div", {
  name: "MuiDateRangePickerToolbar",
  slot: "Container",
  overridesResolver: (_, styles) => styles.container
})({
  display: "flex"
});
var DateRangePickerToolbar = React19.forwardRef(function DateRangePickerToolbar2(inProps, ref) {
  const utils = useUtils();
  const props = useThemeProps({
    props: inProps,
    name: "MuiDateRangePickerToolbar"
  });
  const {
    value: [start, end],
    rangePosition,
    onRangePositionChange,
    toolbarFormat,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded13);
  const translations = usePickersTranslations();
  const startDateValue = start ? utils.formatByString(start, toolbarFormat || utils.formats.shortDate) : translations.start;
  const endDateValue = end ? utils.formatByString(end, toolbarFormat || utils.formats.shortDate) : translations.end;
  const ownerState = props;
  const classes = useUtilityClasses6(ownerState);
  return (0, import_jsx_runtime12.jsx)(DateRangePickerToolbarRoot, _extends({}, other, {
    toolbarTitle: translations.dateRangePickerToolbarTitle,
    isLandscape: false,
    className: clsx_default(className, classes.root),
    ownerState,
    ref,
    children: (0, import_jsx_runtime12.jsxs)(DateRangePickerToolbarContainer, {
      className: classes.container,
      children: [(0, import_jsx_runtime12.jsx)(PickersToolbarButton, {
        variant: start !== null ? "h5" : "h6",
        value: startDateValue,
        selected: rangePosition === "start",
        onClick: () => onRangePositionChange("start")
      }), (0, import_jsx_runtime12.jsxs)(Typography_default, {
        variant: "h5",
        children: [" ", "–", " "]
      }), (0, import_jsx_runtime12.jsx)(PickersToolbarButton, {
        variant: end !== null ? "h5" : "h6",
        value: endDateValue,
        selected: rangePosition === "end",
        onClick: () => onRangePositionChange("end")
      })]
    })
  }));
});
true ? DateRangePickerToolbar.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types10.default.object,
  className: import_prop_types10.default.string,
  disabled: import_prop_types10.default.bool,
  /**
   * If `true`, show the toolbar even in desktop mode.
   * @default `true` for Desktop, `false` for Mobile.
   */
  hidden: import_prop_types10.default.bool,
  onRangePositionChange: import_prop_types10.default.func.isRequired,
  /**
   * Callback called when a toolbar is clicked
   * @template TView
   * @param {TView} view The view to open
   */
  onViewChange: import_prop_types10.default.func.isRequired,
  rangePosition: import_prop_types10.default.oneOf(["end", "start"]).isRequired,
  readOnly: import_prop_types10.default.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types10.default.oneOfType([import_prop_types10.default.arrayOf(import_prop_types10.default.oneOfType([import_prop_types10.default.func, import_prop_types10.default.object, import_prop_types10.default.bool])), import_prop_types10.default.func, import_prop_types10.default.object]),
  titleId: import_prop_types10.default.string,
  /**
   * Toolbar date format.
   */
  toolbarFormat: import_prop_types10.default.string,
  /**
   * Toolbar value placeholder—it is displayed when the value is empty.
   * @default "––"
   */
  toolbarPlaceholder: import_prop_types10.default.node,
  value: import_prop_types10.default.arrayOf(import_prop_types10.default.object).isRequired,
  /**
   * Currently visible picker view.
   */
  view: import_prop_types10.default.oneOf(["day"]).isRequired,
  /**
   * Available views.
   */
  views: import_prop_types10.default.arrayOf(import_prop_types10.default.oneOf(["day"])).isRequired
} : void 0;

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/shared.js
function useDateRangePickerDefaultizedProps(props, name) {
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const themeProps = useThemeProps({
    props,
    name
  });
  const localeText = React20.useMemo(() => {
    var _a;
    if (((_a = themeProps.localeText) == null ? void 0 : _a.toolbarTitle) == null) {
      return themeProps.localeText;
    }
    return _extends({}, themeProps.localeText, {
      dateRangePickerToolbarTitle: themeProps.localeText.toolbarTitle
    });
  }, [themeProps.localeText]);
  return _extends({}, themeProps, {
    localeText,
    disableFuture: themeProps.disableFuture ?? false,
    disablePast: themeProps.disablePast ?? false,
    minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate),
    slots: _extends({
      toolbar: DateRangePickerToolbar
    }, themeProps.slots)
  });
}

// node_modules/@mui/x-date-pickers-pro/dateRangeViewRenderers/dateRangeViewRenderers.js
var React21 = __toESM(require_react());
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var renderDateRangeViewCalendar = ({
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minDate,
  maxDate,
  shouldDisableDate,
  reduceAnimations,
  onMonthChange,
  rangePosition,
  defaultRangePosition,
  onRangePositionChange,
  calendars,
  currentMonthCalendarPosition,
  slots,
  slotProps,
  loading,
  renderLoading,
  disableHighlightToday,
  readOnly,
  disabled,
  showDaysOutsideCurrentMonth,
  dayOfWeekFormatter,
  disableAutoMonthSwitching,
  sx,
  autoFocus,
  fixedWeekNumber,
  disableDragEditing,
  displayWeekNumber,
  timezone,
  availableRangePositions,
  views,
  view,
  onViewChange
}) => (0, import_jsx_runtime13.jsx)(DateRangeCalendar, {
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minDate,
  maxDate,
  shouldDisableDate,
  reduceAnimations,
  onMonthChange,
  rangePosition,
  defaultRangePosition,
  onRangePositionChange,
  calendars,
  currentMonthCalendarPosition,
  slots,
  slotProps,
  loading,
  renderLoading,
  disableHighlightToday,
  readOnly,
  disabled,
  showDaysOutsideCurrentMonth,
  dayOfWeekFormatter,
  disableAutoMonthSwitching,
  sx,
  autoFocus,
  fixedWeekNumber,
  disableDragEditing,
  displayWeekNumber,
  timezone,
  availableRangePositions,
  view,
  views,
  onViewChange
});

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useDesktopRangePicker/useDesktopRangePicker.js
init_extends();
init_objectWithoutPropertiesLoose();
var React23 = __toESM(require_react());
init_useSlotProps();

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useEnrichedRangePickerFieldProps.js
init_objectWithoutPropertiesLoose();
init_extends();
var React22 = __toESM(require_react());
init_resolveComponentProps();
init_useEventCallback();
init_useForkRef();
var _excluded14 = ["clearable", "onClear"];
var useMultiInputFieldSlotProps = ({
  wrapperVariant,
  open,
  actions,
  readOnly,
  labelId,
  disableOpenPicker,
  onBlur,
  rangePosition,
  onRangePositionChange,
  localeText: inLocaleText,
  pickerSlotProps,
  pickerSlots,
  fieldProps,
  anchorRef,
  currentView,
  initialView,
  onViewChange,
  startFieldRef,
  endFieldRef
}) => {
  const translations = usePickersTranslations();
  const handleStartFieldRef = useForkRef(fieldProps.unstableStartFieldRef, startFieldRef);
  const handleEndFieldRef = useForkRef(fieldProps.unstableEndFieldRef, endFieldRef);
  const previousRangePosition = React22.useRef(rangePosition);
  React22.useEffect(() => {
    var _a;
    if (!open) {
      return;
    }
    const currentFieldRef = rangePosition === "start" ? startFieldRef : endFieldRef;
    (_a = currentFieldRef.current) == null ? void 0 : _a.focusField();
    if (!currentFieldRef.current || !currentView) {
      previousRangePosition.current = rangePosition;
      return;
    }
    currentFieldRef.current.setSelectedSections(
      // use the current view or `0` when the range position has just been swapped
      previousRangePosition.current === rangePosition ? currentView : 0
    );
    previousRangePosition.current = rangePosition;
  }, [rangePosition, open, currentView, startFieldRef, endFieldRef]);
  const openRangeStartSelection = (event) => {
    event.stopPropagation();
    onRangePositionChange("start");
    if (!readOnly && !disableOpenPicker) {
      actions.onOpen(event);
    }
  };
  const openRangeEndSelection = (event) => {
    event.stopPropagation();
    onRangePositionChange("end");
    if (!readOnly && !disableOpenPicker) {
      actions.onOpen(event);
    }
  };
  const handleFocusStart = () => {
    if (open) {
      onRangePositionChange("start");
      if (previousRangePosition.current !== "start" && initialView) {
        onViewChange == null ? void 0 : onViewChange(initialView);
      }
    }
  };
  const handleFocusEnd = () => {
    if (open) {
      onRangePositionChange("end");
      if (previousRangePosition.current !== "end" && initialView) {
        onViewChange == null ? void 0 : onViewChange(initialView);
      }
    }
  };
  const slots = _extends({
    textField: pickerSlots == null ? void 0 : pickerSlots.textField,
    root: pickerSlots == null ? void 0 : pickerSlots.fieldRoot,
    separator: pickerSlots == null ? void 0 : pickerSlots.fieldSeparator
  }, fieldProps.slots);
  const slotProps = _extends({}, fieldProps.slotProps, {
    textField: (ownerState) => {
      const resolvedComponentProps = resolveComponentProps_default(pickerSlotProps == null ? void 0 : pickerSlotProps.textField, ownerState);
      let textFieldProps;
      let InputProps;
      if (ownerState.position === "start") {
        textFieldProps = _extends({
          label: (inLocaleText == null ? void 0 : inLocaleText.start) ?? translations.start,
          onKeyDown: onSpaceOrEnter(openRangeStartSelection),
          onFocus: handleFocusStart,
          focused: open ? rangePosition === "start" : void 0
        }, !readOnly && !fieldProps.disabled && {
          onClick: openRangeStartSelection
        }, wrapperVariant === "mobile" && {
          readOnly: true
        });
        if (anchorRef) {
          InputProps = _extends({}, resolvedComponentProps == null ? void 0 : resolvedComponentProps.InputProps, {
            ref: anchorRef
          });
        }
      } else {
        textFieldProps = _extends({
          label: (inLocaleText == null ? void 0 : inLocaleText.end) ?? translations.end,
          onKeyDown: onSpaceOrEnter(openRangeEndSelection),
          onFocus: handleFocusEnd,
          focused: open ? rangePosition === "end" : void 0
        }, !readOnly && !fieldProps.disabled && {
          onClick: openRangeEndSelection
        }, wrapperVariant === "mobile" && {
          readOnly: true
        });
        InputProps = resolvedComponentProps == null ? void 0 : resolvedComponentProps.InputProps;
      }
      return _extends({}, labelId != null && {
        id: `${labelId}-${ownerState.position}`
      }, textFieldProps, resolveComponentProps_default(pickerSlotProps == null ? void 0 : pickerSlotProps.textField, ownerState), {
        InputProps
      });
    },
    root: (ownerState) => {
      const rootProps = {
        onBlur
      };
      return _extends({}, rootProps, resolveComponentProps_default(pickerSlotProps == null ? void 0 : pickerSlotProps.fieldRoot, ownerState));
    },
    separator: pickerSlotProps == null ? void 0 : pickerSlotProps.fieldSeparator
  });
  const _ref = fieldProps, restFieldProps = _objectWithoutPropertiesLoose(_ref, _excluded14);
  const enrichedFieldProps = _extends({}, restFieldProps, {
    unstableStartFieldRef: handleStartFieldRef,
    unstableEndFieldRef: handleEndFieldRef,
    slots,
    slotProps
  });
  return enrichedFieldProps;
};
var useSingleInputFieldSlotProps = ({
  wrapperVariant,
  open,
  actions,
  readOnly,
  labelId,
  disableOpenPicker,
  label,
  onBlur,
  rangePosition,
  onRangePositionChange,
  startFieldRef,
  endFieldRef,
  pickerSlots,
  pickerSlotProps,
  fieldProps,
  anchorRef,
  currentView
}) => {
  const handleFieldRef = useForkRef(fieldProps.unstableFieldRef, startFieldRef, endFieldRef);
  React22.useEffect(() => {
    var _a;
    if (!open || !startFieldRef.current) {
      return;
    }
    if (startFieldRef.current.isFieldFocused()) {
      return;
    }
    if (currentView) {
      const sections = startFieldRef.current.getSections().map((section) => section.type);
      const newSelectedSection = rangePosition === "start" ? sections.indexOf(currentView) : sections.lastIndexOf(currentView);
      (_a = startFieldRef.current) == null ? void 0 : _a.focusField(newSelectedSection);
    }
  }, [rangePosition, open, currentView, startFieldRef]);
  const updateRangePosition = () => {
    var _a, _b;
    if (!((_a = startFieldRef.current) == null ? void 0 : _a.isFieldFocused())) {
      return;
    }
    const sections = startFieldRef.current.getSections();
    const activeSectionIndex = (_b = startFieldRef.current) == null ? void 0 : _b.getActiveSectionIndex();
    const domRangePosition = activeSectionIndex == null || activeSectionIndex < sections.length / 2 ? "start" : "end";
    if (domRangePosition != null && domRangePosition !== rangePosition) {
      onRangePositionChange(domRangePosition);
    }
  };
  const handleSelectedSectionsChange = useEventCallback_default((selectedSection) => {
    var _a;
    setTimeout(updateRangePosition);
    (_a = fieldProps.onSelectedSectionsChange) == null ? void 0 : _a.call(fieldProps, selectedSection);
  });
  const openPicker = (event) => {
    event.stopPropagation();
    if (!readOnly && !disableOpenPicker) {
      actions.onOpen(event);
    }
  };
  const slots = _extends({}, fieldProps.slots, {
    textField: pickerSlots == null ? void 0 : pickerSlots.textField,
    clearButton: pickerSlots == null ? void 0 : pickerSlots.clearButton,
    clearIcon: pickerSlots == null ? void 0 : pickerSlots.clearIcon
  });
  const slotProps = _extends({}, fieldProps.slotProps, {
    textField: pickerSlotProps == null ? void 0 : pickerSlotProps.textField,
    clearButton: pickerSlots == null ? void 0 : pickerSlots.clearButton,
    clearIcon: pickerSlots == null ? void 0 : pickerSlots.clearIcon
  });
  const enrichedFieldProps = _extends({}, fieldProps, {
    slots,
    slotProps,
    label,
    unstableFieldRef: handleFieldRef,
    onKeyDown: onSpaceOrEnter(openPicker, fieldProps.onKeyDown),
    onSelectedSectionsChange: handleSelectedSectionsChange,
    onBlur,
    InputProps: _extends({
      ref: anchorRef
    }, fieldProps == null ? void 0 : fieldProps.InputProps),
    focused: open ? true : void 0
  }, labelId != null && {
    id: labelId
  }, wrapperVariant === "mobile" && {
    readOnly: true
  }, !readOnly && !fieldProps.disabled && {
    onClick: openPicker
  });
  return enrichedFieldProps;
};
var useEnrichedRangePickerFieldProps = (params) => {
  if (true) {
    const fieldTypeRef = React22.useRef(params.fieldType);
    if (params.fieldType !== fieldTypeRef.current) {
      console.error("Should not switch between a multi input field and a single input field on a range picker.");
    }
  }
  if (params.fieldType === "multi-input") {
    return useMultiInputFieldSlotProps(params);
  }
  return useSingleInputFieldSlotProps(params);
};

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useDesktopRangePicker/useDesktopRangePicker.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var _excluded15 = ["props"];
var releaseInfo3 = getReleaseInfo();
var useDesktopRangePicker = (_ref) => {
  let {
    props
  } = _ref, pickerParams = _objectWithoutPropertiesLoose(_ref, _excluded15);
  useLicenseVerifier("x-date-pickers-pro", releaseInfo3);
  const {
    slots,
    slotProps,
    className,
    sx,
    format,
    formatDensity,
    enableAccessibleFieldDOMStructure,
    selectedSections,
    onSelectedSectionsChange,
    timezone,
    label,
    inputRef,
    name,
    readOnly,
    disabled,
    autoFocus,
    disableOpenPicker,
    localeText,
    reduceAnimations
  } = props;
  const fieldContainerRef = React23.useRef(null);
  const anchorRef = React23.useRef(null);
  const popperRef = React23.useRef(null);
  const startFieldRef = React23.useRef(null);
  const endFieldRef = React23.useRef(null);
  const initialView = React23.useRef(props.openTo ?? null);
  const fieldType = slots.field.fieldType ?? "multi-input";
  const {
    rangePosition,
    onRangePositionChange
  } = useRangePosition(props, fieldType === "single-input" ? startFieldRef : void 0);
  const {
    open,
    actions,
    layoutProps,
    renderCurrentView,
    shouldRestoreFocus,
    fieldProps: pickerFieldProps
  } = usePicker(_extends({}, pickerParams, {
    props,
    wrapperVariant: "desktop",
    autoFocusView: false,
    fieldRef: rangePosition === "start" ? startFieldRef : endFieldRef,
    additionalViewProps: {
      rangePosition,
      onRangePositionChange
    }
  }));
  React23.useEffect(() => {
    if (layoutProps.view) {
      initialView.current = layoutProps.view;
    }
  }, []);
  const handleBlur = () => {
    executeInTheNextEventLoopTick(() => {
      var _a, _b;
      if (((_a = fieldContainerRef.current) == null ? void 0 : _a.contains(getActiveElement(document))) || ((_b = popperRef.current) == null ? void 0 : _b.contains(getActiveElement(document)))) {
        return;
      }
      actions.onDismiss();
    });
  };
  const Field = slots.field;
  const fieldProps = useSlotProps_default({
    elementType: Field,
    externalSlotProps: slotProps == null ? void 0 : slotProps.field,
    additionalProps: _extends({}, pickerFieldProps, {
      readOnly,
      disabled,
      className,
      sx,
      format,
      formatDensity,
      enableAccessibleFieldDOMStructure,
      selectedSections,
      onSelectedSectionsChange,
      timezone,
      autoFocus: autoFocus && !props.open,
      ref: fieldContainerRef
    }, fieldType === "single-input" ? {
      inputRef,
      name
    } : {}),
    ownerState: props
  });
  const enrichedFieldProps = useEnrichedRangePickerFieldProps({
    wrapperVariant: "desktop",
    fieldType,
    open,
    actions,
    readOnly,
    disableOpenPicker,
    label,
    localeText,
    onBlur: handleBlur,
    rangePosition,
    onRangePositionChange,
    pickerSlotProps: slotProps,
    pickerSlots: slots,
    fieldProps,
    anchorRef,
    startFieldRef,
    endFieldRef,
    currentView: layoutProps.view !== props.openTo ? layoutProps.view : void 0,
    initialView: initialView.current ?? void 0,
    onViewChange: layoutProps.onViewChange
  });
  const slotPropsForLayout = _extends({}, slotProps, {
    tabs: _extends({}, slotProps == null ? void 0 : slotProps.tabs, {
      rangePosition,
      onRangePositionChange
    }),
    toolbar: _extends({}, slotProps == null ? void 0 : slotProps.toolbar, {
      rangePosition,
      onRangePositionChange
    })
  });
  const Layout = (slots == null ? void 0 : slots.layout) ?? PickersLayout;
  const renderPicker = () => (0, import_jsx_runtime14.jsxs)(LocalizationProvider, {
    localeText,
    children: [(0, import_jsx_runtime14.jsx)(Field, _extends({}, enrichedFieldProps)), (0, import_jsx_runtime14.jsx)(PickersPopper, _extends({
      role: "tooltip",
      placement: "bottom-start",
      containerRef: popperRef,
      anchorEl: anchorRef.current,
      onBlur: handleBlur
    }, actions, {
      open,
      slots,
      slotProps,
      shouldRestoreFocus,
      reduceAnimations,
      children: (0, import_jsx_runtime14.jsx)(Layout, _extends({}, layoutProps, slotProps == null ? void 0 : slotProps.layout, {
        slots,
        slotProps: slotPropsForLayout,
        children: renderCurrentView()
      }))
    }))]
  });
  return {
    renderPicker
  };
};

// node_modules/@mui/x-date-pickers-pro/DesktopDateRangePicker/DesktopDateRangePicker.js
var DesktopDateRangePicker = React24.forwardRef(function DesktopDateRangePicker2(inProps, ref) {
  var _a;
  const defaultizedProps = useDateRangePickerDefaultizedProps(inProps, "MuiDesktopDateRangePicker");
  const viewRenderers = _extends({
    day: renderDateRangeViewCalendar
  }, defaultizedProps.viewRenderers);
  const props = _extends({}, defaultizedProps, {
    viewRenderers,
    calendars: defaultizedProps.calendars ?? 2,
    views: ["day"],
    openTo: "day",
    slots: _extends({
      field: MultiInputDateRangeField
    }, defaultizedProps.slots),
    slotProps: _extends({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _a2;
        return _extends({}, resolveComponentProps_default((_a2 = defaultizedProps.slotProps) == null ? void 0 : _a2.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      toolbar: _extends({
        hidden: true
      }, (_a = defaultizedProps.slotProps) == null ? void 0 : _a.toolbar)
    })
  });
  const {
    renderPicker
  } = useDesktopRangePicker({
    props,
    valueManager: rangeValueManager,
    valueType: "date",
    validator: validateDateRange
  });
  return renderPicker();
});
DesktopDateRangePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types11.default.bool,
  /**
   * The number of calendars to render on **desktop**.
   * @default 2
   */
  calendars: import_prop_types11.default.oneOf([1, 2, 3]),
  className: import_prop_types11.default.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: import_prop_types11.default.bool,
  /**
   * Position the current month is rendered in.
   * @default 1
   */
  currentMonthCalendarPosition: import_prop_types11.default.oneOf([1, 2, 3]),
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: import_prop_types11.default.func,
  /**
   * The initial position in the edited date range.
   * Used when the component is not controlled.
   * @default 'start'
   */
  defaultRangePosition: import_prop_types11.default.oneOf(["end", "start"]),
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types11.default.arrayOf(import_prop_types11.default.object),
  /**
   * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
   * @default false
   */
  disableAutoMonthSwitching: import_prop_types11.default.bool,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types11.default.bool,
  /**
   * If `true`, editing dates by dragging is disabled.
   * @default false
   */
  disableDragEditing: import_prop_types11.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types11.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types11.default.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: import_prop_types11.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types11.default.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: import_prop_types11.default.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: import_prop_types11.default.any,
  /**
   * The day view will show as many weeks as needed after the end of the current month to match this value.
   * Put it to 6 to have a fixed number of weeks in Gregorian calendars
   */
  fixedWeekNumber: import_prop_types11.default.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: import_prop_types11.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types11.default.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   * Ignored if the field has several inputs.
   */
  inputRef: refType_default,
  /**
   * The label content.
   * Ignored if the field has several inputs.
   */
  label: import_prop_types11.default.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: import_prop_types11.default.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: import_prop_types11.default.object,
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: import_prop_types11.default.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: import_prop_types11.default.object,
  /**
   * Name attribute used by the `input` element in the Field.
   * Ignored if the field has several inputs.
   */
  name: import_prop_types11.default.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onAccept: import_prop_types11.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types11.default.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: import_prop_types11.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types11.default.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: import_prop_types11.default.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: import_prop_types11.default.func,
  /**
   * Callback fired when the range position changes.
   * @param {RangePosition} rangePosition The new range position.
   */
  onRangePositionChange: import_prop_types11.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types11.default.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: import_prop_types11.default.bool,
  /**
   * The position in the currently edited date range.
   * Used when the component position is controlled.
   */
  rangePosition: import_prop_types11.default.oneOf(["end", "start"]),
  readOnly: import_prop_types11.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types11.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: import_prop_types11.default.object,
  /**
   * Component rendered on the "day" view when `props.loading` is true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => "..."
   */
  renderLoading: import_prop_types11.default.func,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types11.default.oneOfType([import_prop_types11.default.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types11.default.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types11.default.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types11.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types11.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types11.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types11.default.oneOfType([import_prop_types11.default.arrayOf(import_prop_types11.default.oneOfType([import_prop_types11.default.func, import_prop_types11.default.object, import_prop_types11.default.bool])), import_prop_types11.default.func, import_prop_types11.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types11.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types11.default.arrayOf(import_prop_types11.default.object),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be used.
   */
  viewRenderers: import_prop_types11.default.shape({
    day: import_prop_types11.default.func
  })
};

// node_modules/@mui/x-date-pickers-pro/MobileDateRangePicker/MobileDateRangePicker.js
init_extends();
var React26 = __toESM(require_react());
var import_prop_types12 = __toESM(require_prop_types());
init_resolveComponentProps();
init_esm();

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMobileRangePicker/useMobileRangePicker.js
init_extends();
init_objectWithoutPropertiesLoose();
var React25 = __toESM(require_react());
init_useSlotProps();
init_useId();
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var _excluded16 = ["props"];
var releaseInfo4 = getReleaseInfo();
var useMobileRangePicker = (_ref) => {
  var _a;
  let {
    props
  } = _ref, pickerParams = _objectWithoutPropertiesLoose(_ref, _excluded16);
  useLicenseVerifier("x-date-pickers-pro", releaseInfo4);
  const {
    slots,
    slotProps: innerSlotProps,
    className,
    sx,
    format,
    formatDensity,
    enableAccessibleFieldDOMStructure,
    selectedSections,
    onSelectedSectionsChange,
    timezone,
    label,
    inputRef,
    name,
    readOnly,
    disabled,
    disableOpenPicker,
    localeText
  } = props;
  const startFieldRef = React25.useRef(null);
  const endFieldRef = React25.useRef(null);
  const fieldType = slots.field.fieldType ?? "multi-input";
  const {
    rangePosition,
    onRangePositionChange
  } = useRangePosition(props, fieldType === "single-input" ? startFieldRef : void 0);
  const labelId = useId();
  const contextTranslations = usePickersTranslations();
  const {
    open,
    actions,
    layoutProps,
    renderCurrentView,
    fieldProps: pickerFieldProps
  } = usePicker(_extends({}, pickerParams, {
    props,
    wrapperVariant: "mobile",
    autoFocusView: true,
    fieldRef: rangePosition === "start" ? startFieldRef : endFieldRef,
    additionalViewProps: {
      rangePosition,
      onRangePositionChange
    }
  }));
  const Field = slots.field;
  const fieldProps = useSlotProps_default({
    elementType: Field,
    externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.field,
    additionalProps: _extends({}, pickerFieldProps, {
      readOnly: readOnly ?? true,
      disabled,
      className,
      sx,
      format,
      formatDensity,
      enableAccessibleFieldDOMStructure,
      selectedSections,
      onSelectedSectionsChange,
      timezone
    }, fieldType === "single-input" ? {
      inputRef,
      name
    } : {}),
    ownerState: props
  });
  const isToolbarHidden = ((_a = innerSlotProps == null ? void 0 : innerSlotProps.toolbar) == null ? void 0 : _a.hidden) ?? false;
  const enrichedFieldProps = useEnrichedRangePickerFieldProps({
    wrapperVariant: "mobile",
    fieldType,
    open,
    actions,
    readOnly,
    labelId,
    disableOpenPicker,
    label,
    localeText,
    rangePosition,
    onRangePositionChange,
    pickerSlots: slots,
    pickerSlotProps: innerSlotProps,
    fieldProps,
    startFieldRef,
    endFieldRef
  });
  const slotPropsForLayout = _extends({}, innerSlotProps, {
    tabs: _extends({}, innerSlotProps == null ? void 0 : innerSlotProps.tabs, {
      rangePosition,
      onRangePositionChange
    }),
    toolbar: _extends({}, innerSlotProps == null ? void 0 : innerSlotProps.toolbar, {
      titleId: labelId,
      rangePosition,
      onRangePositionChange
    })
  });
  const Layout = (slots == null ? void 0 : slots.layout) ?? PickersLayout;
  const finalLocaleText = _extends({}, contextTranslations, localeText);
  let labelledById = pickerParams.valueType === "date-time" ? `${labelId}-start-toolbar ${labelId}-end-toolbar` : labelId;
  if (isToolbarHidden) {
    const labels = [];
    if (fieldType === "multi-input") {
      if (finalLocaleText.start) {
        labels.push(`${labelId}-start-label`);
      }
      if (finalLocaleText.end) {
        labels.push(`${labelId}-end-label`);
      }
    } else if (label != null) {
      labels.push(`${labelId}-label`);
    }
    labelledById = labels.length > 0 ? labels.join(" ") : void 0;
  }
  const slotProps = _extends({}, innerSlotProps, {
    mobilePaper: _extends({
      "aria-labelledby": labelledById
    }, innerSlotProps == null ? void 0 : innerSlotProps.mobilePaper)
  });
  const renderPicker = () => (0, import_jsx_runtime15.jsxs)(LocalizationProvider, {
    localeText,
    children: [(0, import_jsx_runtime15.jsx)(Field, _extends({}, enrichedFieldProps)), (0, import_jsx_runtime15.jsx)(PickersModalDialog, _extends({}, actions, {
      open,
      slots,
      slotProps,
      children: (0, import_jsx_runtime15.jsx)(Layout, _extends({}, layoutProps, slotProps == null ? void 0 : slotProps.layout, {
        slots,
        slotProps: slotPropsForLayout,
        children: renderCurrentView()
      }))
    }))]
  });
  return {
    renderPicker
  };
};

// node_modules/@mui/x-date-pickers-pro/MobileDateRangePicker/MobileDateRangePicker.js
var MobileDateRangePicker = React26.forwardRef(function MobileDateRangePicker2(inProps, ref) {
  var _a;
  const defaultizedProps = useDateRangePickerDefaultizedProps(inProps, "MuiMobileDateRangePicker");
  const viewRenderers = _extends({
    day: renderDateRangeViewCalendar
  }, defaultizedProps.viewRenderers);
  const props = _extends({}, defaultizedProps, {
    viewRenderers,
    // Force one calendar on mobile to avoid layout issues
    calendars: 1,
    views: ["day"],
    openTo: "day",
    slots: _extends({
      field: MultiInputDateRangeField
    }, defaultizedProps.slots),
    slotProps: _extends({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _a2;
        return _extends({}, resolveComponentProps_default((_a2 = defaultizedProps.slotProps) == null ? void 0 : _a2.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      toolbar: _extends({
        hidden: false
      }, (_a = defaultizedProps.slotProps) == null ? void 0 : _a.toolbar)
    })
  });
  const {
    renderPicker
  } = useMobileRangePicker({
    props,
    valueManager: rangeValueManager,
    valueType: "date",
    validator: validateDateRange
  });
  return renderPicker();
});
MobileDateRangePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types12.default.bool,
  className: import_prop_types12.default.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: import_prop_types12.default.bool,
  /**
   * Position the current month is rendered in.
   * @default 1
   */
  currentMonthCalendarPosition: import_prop_types12.default.oneOf([1, 2, 3]),
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: import_prop_types12.default.func,
  /**
   * The initial position in the edited date range.
   * Used when the component is not controlled.
   * @default 'start'
   */
  defaultRangePosition: import_prop_types12.default.oneOf(["end", "start"]),
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types12.default.arrayOf(import_prop_types12.default.object),
  /**
   * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
   * @default false
   */
  disableAutoMonthSwitching: import_prop_types12.default.bool,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types12.default.bool,
  /**
   * If `true`, editing dates by dragging is disabled.
   * @default false
   */
  disableDragEditing: import_prop_types12.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types12.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types12.default.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: import_prop_types12.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types12.default.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: import_prop_types12.default.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: import_prop_types12.default.any,
  /**
   * The day view will show as many weeks as needed after the end of the current month to match this value.
   * Put it to 6 to have a fixed number of weeks in Gregorian calendars
   */
  fixedWeekNumber: import_prop_types12.default.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: import_prop_types12.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types12.default.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   * Ignored if the field has several inputs.
   */
  inputRef: refType_default,
  /**
   * The label content.
   * Ignored if the field has several inputs.
   */
  label: import_prop_types12.default.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: import_prop_types12.default.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: import_prop_types12.default.object,
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: import_prop_types12.default.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: import_prop_types12.default.object,
  /**
   * Name attribute used by the `input` element in the Field.
   * Ignored if the field has several inputs.
   */
  name: import_prop_types12.default.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onAccept: import_prop_types12.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types12.default.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: import_prop_types12.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types12.default.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: import_prop_types12.default.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: import_prop_types12.default.func,
  /**
   * Callback fired when the range position changes.
   * @param {RangePosition} rangePosition The new range position.
   */
  onRangePositionChange: import_prop_types12.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types12.default.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: import_prop_types12.default.bool,
  /**
   * The position in the currently edited date range.
   * Used when the component position is controlled.
   */
  rangePosition: import_prop_types12.default.oneOf(["end", "start"]),
  readOnly: import_prop_types12.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types12.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: import_prop_types12.default.object,
  /**
   * Component rendered on the "day" view when `props.loading` is true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => "..."
   */
  renderLoading: import_prop_types12.default.func,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types12.default.oneOfType([import_prop_types12.default.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types12.default.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types12.default.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types12.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types12.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types12.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types12.default.oneOfType([import_prop_types12.default.arrayOf(import_prop_types12.default.oneOfType([import_prop_types12.default.func, import_prop_types12.default.object, import_prop_types12.default.bool])), import_prop_types12.default.func, import_prop_types12.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types12.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types12.default.arrayOf(import_prop_types12.default.object),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be used.
   */
  viewRenderers: import_prop_types12.default.shape({
    day: import_prop_types12.default.func
  })
};

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/DateRangePicker.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var _excluded17 = ["desktopModeMediaQuery"];
var DateRangePicker = React27.forwardRef(function DateRangePicker2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDateRangePicker"
  });
  const {
    desktopModeMediaQuery = "@media (pointer: fine)"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded17);
  const isDesktop = useMediaQuery(desktopModeMediaQuery, {
    defaultMatches: true
  });
  if (isDesktop) {
    return (0, import_jsx_runtime16.jsx)(DesktopDateRangePicker, _extends({
      ref
    }, other));
  }
  return (0, import_jsx_runtime16.jsx)(MobileDateRangePicker, _extends({
    ref
  }, other));
});
true ? DateRangePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types13.default.bool,
  /**
   * The number of calendars to render on **desktop**.
   * @default 2
   */
  calendars: import_prop_types13.default.oneOf([1, 2, 3]),
  className: import_prop_types13.default.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: import_prop_types13.default.bool,
  /**
   * Position the current month is rendered in.
   * @default 1
   */
  currentMonthCalendarPosition: import_prop_types13.default.oneOf([1, 2, 3]),
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: import_prop_types13.default.func,
  /**
   * The initial position in the edited date range.
   * Used when the component is not controlled.
   * @default 'start'
   */
  defaultRangePosition: import_prop_types13.default.oneOf(["end", "start"]),
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types13.default.arrayOf(import_prop_types13.default.object),
  /**
   * CSS media query when `Mobile` mode will be changed to `Desktop`.
   * @default '@media (pointer: fine)'
   * @example '@media (min-width: 720px)' or theme.breakpoints.up("sm")
   */
  desktopModeMediaQuery: import_prop_types13.default.string,
  /**
   * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
   * @default false
   */
  disableAutoMonthSwitching: import_prop_types13.default.bool,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types13.default.bool,
  /**
   * If `true`, editing dates by dragging is disabled.
   * @default false
   */
  disableDragEditing: import_prop_types13.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types13.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types13.default.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: import_prop_types13.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types13.default.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: import_prop_types13.default.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: import_prop_types13.default.any,
  /**
   * The day view will show as many weeks as needed after the end of the current month to match this value.
   * Put it to 6 to have a fixed number of weeks in Gregorian calendars
   */
  fixedWeekNumber: import_prop_types13.default.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: import_prop_types13.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types13.default.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   * Ignored if the field has several inputs.
   */
  inputRef: refType_default,
  /**
   * The label content.
   * Ignored if the field has several inputs.
   */
  label: import_prop_types13.default.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: import_prop_types13.default.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: import_prop_types13.default.object,
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: import_prop_types13.default.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: import_prop_types13.default.object,
  /**
   * Name attribute used by the `input` element in the Field.
   * Ignored if the field has several inputs.
   */
  name: import_prop_types13.default.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onAccept: import_prop_types13.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types13.default.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: import_prop_types13.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types13.default.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: import_prop_types13.default.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: import_prop_types13.default.func,
  /**
   * Callback fired when the range position changes.
   * @param {RangePosition} rangePosition The new range position.
   */
  onRangePositionChange: import_prop_types13.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types13.default.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: import_prop_types13.default.bool,
  /**
   * The position in the currently edited date range.
   * Used when the component position is controlled.
   */
  rangePosition: import_prop_types13.default.oneOf(["end", "start"]),
  readOnly: import_prop_types13.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types13.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: import_prop_types13.default.object,
  /**
   * Component rendered on the "day" view when `props.loading` is true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => "..."
   */
  renderLoading: import_prop_types13.default.func,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types13.default.oneOfType([import_prop_types13.default.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types13.default.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types13.default.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types13.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types13.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types13.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types13.default.oneOfType([import_prop_types13.default.arrayOf(import_prop_types13.default.oneOfType([import_prop_types13.default.func, import_prop_types13.default.object, import_prop_types13.default.bool])), import_prop_types13.default.func, import_prop_types13.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types13.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types13.default.arrayOf(import_prop_types13.default.object),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be used.
   */
  viewRenderers: import_prop_types13.default.shape({
    day: import_prop_types13.default.func
  })
} : void 0;

// node_modules/@mui/x-date-pickers-pro/StaticDateRangePicker/StaticDateRangePicker.js
init_extends();
var React29 = __toESM(require_react());
var import_prop_types14 = __toESM(require_prop_types());

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useStaticRangePicker/useStaticRangePicker.js
init_extends();
init_objectWithoutPropertiesLoose();
var React28 = __toESM(require_react());
init_clsx();
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var _excluded18 = ["props", "ref"];
var PickerStaticLayout = styled_default(PickersLayout)(({
  theme
}) => ({
  overflow: "hidden",
  minWidth: DIALOG_WIDTH,
  backgroundColor: (theme.vars || theme).palette.background.paper
}));
var useStaticRangePicker = (_ref) => {
  let {
    props,
    ref
  } = _ref, pickerParams = _objectWithoutPropertiesLoose(_ref, _excluded18);
  const {
    localeText,
    slots,
    slotProps,
    className,
    sx,
    displayStaticWrapperAs,
    autoFocus
  } = props;
  const {
    rangePosition,
    onRangePositionChange
  } = useRangePosition(props);
  const {
    layoutProps,
    renderCurrentView
  } = usePicker(_extends({}, pickerParams, {
    props,
    autoFocusView: autoFocus ?? false,
    fieldRef: void 0,
    additionalViewProps: {
      rangePosition,
      onRangePositionChange
    },
    wrapperVariant: displayStaticWrapperAs
  }));
  const Layout = (slots == null ? void 0 : slots.layout) ?? PickerStaticLayout;
  const slotPropsForLayout = _extends({}, slotProps, {
    toolbar: _extends({}, slotProps == null ? void 0 : slotProps.toolbar, {
      rangePosition,
      onRangePositionChange
    })
  });
  const renderPicker = () => {
    var _a, _b, _c;
    return (0, import_jsx_runtime17.jsx)(LocalizationProvider, {
      localeText,
      children: (0, import_jsx_runtime17.jsx)(Layout, _extends({}, layoutProps, slotProps == null ? void 0 : slotProps.layout, {
        slots,
        slotProps: slotPropsForLayout,
        sx: [...Array.isArray(sx) ? sx : [sx], ...Array.isArray((_a = slotProps == null ? void 0 : slotProps.layout) == null ? void 0 : _a.sx) ? slotProps.layout.sx : [(_b = slotProps == null ? void 0 : slotProps.layout) == null ? void 0 : _b.sx]],
        className: clsx_default(className, (_c = slotProps == null ? void 0 : slotProps.layout) == null ? void 0 : _c.className),
        ref,
        children: renderCurrentView()
      }))
    });
  };
  return {
    renderPicker
  };
};

// node_modules/@mui/x-date-pickers-pro/StaticDateRangePicker/StaticDateRangePicker.js
var StaticDateRangePicker = React29.forwardRef(function StaticDateRangePicker2(inProps, ref) {
  var _a;
  const defaultizedProps = useDateRangePickerDefaultizedProps(inProps, "MuiStaticDateRangePicker");
  const displayStaticWrapperAs = defaultizedProps.displayStaticWrapperAs ?? "mobile";
  const viewRenderers = _extends({
    day: renderDateRangeViewCalendar
  }, defaultizedProps.viewRenderers);
  const props = _extends({}, defaultizedProps, {
    viewRenderers,
    displayStaticWrapperAs,
    views: ["day"],
    openTo: "day",
    calendars: defaultizedProps.calendars ?? (displayStaticWrapperAs === "mobile" ? 1 : 2),
    slotProps: _extends({}, defaultizedProps.slotProps, {
      toolbar: _extends({
        hidden: displayStaticWrapperAs === "desktop"
      }, (_a = defaultizedProps.slotProps) == null ? void 0 : _a.toolbar)
    })
  });
  const {
    renderPicker
  } = useStaticRangePicker({
    props,
    valueManager: rangeValueManager,
    valueType: "date",
    validator: validateDateRange,
    ref
  });
  return renderPicker();
});
StaticDateRangePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types14.default.bool,
  /**
   * The number of calendars to render.
   * @default 1 if `displayStaticWrapperAs === 'mobile'`, 2 otherwise.
   */
  calendars: import_prop_types14.default.oneOf([1, 2, 3]),
  className: import_prop_types14.default.string,
  /**
   * Position the current month is rendered in.
   * @default 1
   */
  currentMonthCalendarPosition: import_prop_types14.default.oneOf([1, 2, 3]),
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: import_prop_types14.default.func,
  /**
   * The initial position in the edited date range.
   * Used when the component is not controlled.
   * @default 'start'
   */
  defaultRangePosition: import_prop_types14.default.oneOf(["end", "start"]),
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types14.default.arrayOf(import_prop_types14.default.object),
  /**
   * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
   * @default false
   */
  disableAutoMonthSwitching: import_prop_types14.default.bool,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types14.default.bool,
  /**
   * If `true`, editing dates by dragging is disabled.
   * @default false
   */
  disableDragEditing: import_prop_types14.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types14.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types14.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types14.default.bool,
  /**
   * Force static wrapper inner components to be rendered in mobile or desktop mode.
   * @default "mobile"
   */
  displayStaticWrapperAs: import_prop_types14.default.oneOf(["desktop", "mobile"]),
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: import_prop_types14.default.bool,
  /**
   * The day view will show as many weeks as needed after the end of the current month to match this value.
   * Put it to 6 to have a fixed number of weeks in Gregorian calendars
   */
  fixedWeekNumber: import_prop_types14.default.number,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: import_prop_types14.default.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: import_prop_types14.default.object,
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: import_prop_types14.default.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: import_prop_types14.default.object,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onAccept: import_prop_types14.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types14.default.func,
  /**
   * Callback fired when component requests to be closed.
   * Can be fired when selecting (by default on `desktop` mode) or clearing a value.
   * @deprecated Please avoid using as it will be removed in next major version.
   */
  onClose: import_prop_types14.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types14.default.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: import_prop_types14.default.func,
  /**
   * Callback fired when the range position changes.
   * @param {RangePosition} rangePosition The new range position.
   */
  onRangePositionChange: import_prop_types14.default.func,
  /**
   * The position in the currently edited date range.
   * Used when the component position is controlled.
   */
  rangePosition: import_prop_types14.default.oneOf(["end", "start"]),
  readOnly: import_prop_types14.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types14.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: import_prop_types14.default.object,
  /**
   * Component rendered on the "day" view when `props.loading` is true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => "..."
   */
  renderLoading: import_prop_types14.default.func,
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types14.default.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types14.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types14.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types14.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types14.default.oneOfType([import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.func, import_prop_types14.default.object, import_prop_types14.default.bool])), import_prop_types14.default.func, import_prop_types14.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types14.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types14.default.arrayOf(import_prop_types14.default.object),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be used.
   */
  viewRenderers: import_prop_types14.default.shape({
    day: import_prop_types14.default.func
  })
};

// node_modules/@mui/x-date-pickers-pro/DateTimeRangePicker/DateTimeRangePicker.js
init_extends();
init_objectWithoutPropertiesLoose();
var React34 = __toESM(require_react());
var import_prop_types19 = __toESM(require_prop_types());
init_esm();

// node_modules/@mui/x-date-pickers-pro/DesktopDateTimeRangePicker/DesktopDateTimeRangePicker.js
init_extends();
init_objectWithoutPropertiesLoose();
var React32 = __toESM(require_react());
var import_prop_types17 = __toESM(require_prop_types());
init_resolveComponentProps();
init_esm();

// node_modules/@mui/x-date-pickers-pro/DateTimeRangePicker/shared.js
init_extends();

// node_modules/@mui/x-date-pickers-pro/DateTimeRangePicker/DateTimeRangePickerToolbar.js
init_extends();
init_objectWithoutPropertiesLoose();
var React30 = __toESM(require_react());
var import_prop_types15 = __toESM(require_prop_types());
init_clsx();
init_composeClasses();

// node_modules/@mui/x-date-pickers-pro/DateTimeRangePicker/dateTimeRangePickerToolbarClasses.js
init_esm();
function getDateTimeRangePickerToolbarUtilityClass(slot) {
  return generateUtilityClass("MuiDateTimeRangePickerToolbar", slot);
}
var dateTimeRangePickerToolbarClasses = generateUtilityClasses("MuiDateTimeRangePickerToolbar", ["root", "startToolbar", "endToolbar"]);

// node_modules/@mui/x-date-pickers-pro/DateTimeRangePicker/DateTimeRangePickerToolbar.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var _excluded19 = ["value", "rangePosition", "onRangePositionChange", "className", "onViewChange", "toolbarVariant", "onChange", "classes", "view", "isLandscape", "views", "ampm", "disabled", "readOnly", "hidden", "toolbarFormat", "toolbarPlaceholder", "titleId", "sx"];
var useUtilityClasses7 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    startToolbar: ["startToolbar"],
    endToolbar: ["endToolbar"]
  };
  return composeClasses(slots, getDateTimeRangePickerToolbarUtilityClass, classes);
};
var DateTimeRangePickerToolbarRoot = styled_default("div", {
  name: "MuiDateTimeRangePickerToolbar",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})({
  display: "flex",
  flexDirection: "column"
});
var DateTimeRangePickerToolbarStart = styled_default(DateTimePickerToolbar, {
  name: "MuiDateTimeRangePickerToolbar",
  slot: "StartToolbar",
  overridesResolver: (_, styles) => styles.startToolbar
})({
  borderBottom: "none",
  variants: [{
    props: ({
      toolbarVariant
    }) => toolbarVariant !== "desktop",
    style: {
      padding: "12px 8px 0 12px"
    }
  }, {
    props: {
      toolbarVariant: "desktop"
    },
    style: {
      paddingBottom: 0
    }
  }]
});
var DateTimeRangePickerToolbarEnd = styled_default(DateTimePickerToolbar, {
  name: "MuiDateTimeRangePickerToolbar",
  slot: "EndToolbar",
  overridesResolver: (_, styles) => styles.endToolbar
})({
  variants: [{
    props: ({
      toolbarVariant
    }) => toolbarVariant !== "desktop",
    style: {
      padding: "12px 8px 12px 12px"
    }
  }]
});
var DateTimeRangePickerToolbar = React30.forwardRef(function DateTimeRangePickerToolbar2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDateTimeRangePickerToolbar"
  });
  const utils = useUtils();
  const {
    value: [start, end],
    rangePosition,
    onRangePositionChange,
    className,
    onViewChange,
    onChange,
    view,
    isLandscape,
    views,
    ampm,
    disabled,
    readOnly,
    hidden,
    toolbarFormat,
    toolbarPlaceholder,
    titleId,
    sx
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded19);
  const commonToolbarProps = {
    isLandscape,
    views,
    ampm,
    disabled,
    readOnly,
    hidden,
    toolbarFormat,
    toolbarPlaceholder
  };
  const translations = usePickersTranslations();
  const ownerState = props;
  const classes = useUtilityClasses7(ownerState);
  const handleStartRangeViewChange = React30.useCallback((newView) => {
    if (newView === "year" || newView === "month") {
      return;
    }
    if (rangePosition !== "start") {
      onRangePositionChange("start");
    }
    onViewChange(newView);
  }, [onRangePositionChange, onViewChange, rangePosition]);
  const handleEndRangeViewChange = React30.useCallback((newView) => {
    if (newView === "year" || newView === "month") {
      return;
    }
    if (rangePosition !== "end") {
      onRangePositionChange("end");
    }
    onViewChange(newView);
  }, [onRangePositionChange, onViewChange, rangePosition]);
  const handleOnChange = React30.useCallback((newDate) => {
    const {
      nextSelection,
      newRange
    } = calculateRangeChange({
      newDate,
      utils,
      range: props.value,
      rangePosition,
      allowRangeFlip: true
    });
    onRangePositionChange(nextSelection);
    onChange(newRange);
  }, [onChange, onRangePositionChange, props.value, rangePosition, utils]);
  if (hidden) {
    return null;
  }
  return (0, import_jsx_runtime18.jsxs)(DateTimeRangePickerToolbarRoot, _extends({
    className: clsx_default(className, classes.root),
    ownerState,
    ref,
    sx
  }, other, {
    children: [(0, import_jsx_runtime18.jsx)(DateTimeRangePickerToolbarStart, _extends({
      value: start,
      onViewChange: handleStartRangeViewChange,
      toolbarTitle: translations.start,
      ownerState,
      toolbarVariant: "desktop",
      view: rangePosition === "start" ? view : void 0,
      className: classes.startToolbar,
      onChange: handleOnChange,
      titleId: titleId ? `${titleId}-start-toolbar` : void 0
    }, commonToolbarProps)), (0, import_jsx_runtime18.jsx)(DateTimeRangePickerToolbarEnd, _extends({
      value: end,
      onViewChange: handleEndRangeViewChange,
      toolbarTitle: translations.end,
      ownerState,
      toolbarVariant: "desktop",
      view: rangePosition === "end" ? view : void 0,
      className: classes.endToolbar,
      onChange: handleOnChange,
      titleId: titleId ? `${titleId}-end-toolbar` : void 0
    }, commonToolbarProps))]
  }));
});
true ? DateTimeRangePickerToolbar.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  ampm: import_prop_types15.default.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types15.default.object,
  className: import_prop_types15.default.string,
  disabled: import_prop_types15.default.bool,
  /**
   * If `true`, show the toolbar even in desktop mode.
   * @default `true` for Desktop, `false` for Mobile.
   */
  hidden: import_prop_types15.default.bool,
  isLandscape: import_prop_types15.default.bool.isRequired,
  onChange: import_prop_types15.default.func.isRequired,
  onRangePositionChange: import_prop_types15.default.func.isRequired,
  /**
   * Callback called when a toolbar is clicked
   * @template TView
   * @param {TView} view The view to open
   */
  onViewChange: import_prop_types15.default.func.isRequired,
  rangePosition: import_prop_types15.default.oneOf(["end", "start"]).isRequired,
  readOnly: import_prop_types15.default.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types15.default.oneOfType([import_prop_types15.default.arrayOf(import_prop_types15.default.oneOfType([import_prop_types15.default.func, import_prop_types15.default.object, import_prop_types15.default.bool])), import_prop_types15.default.func, import_prop_types15.default.object]),
  titleId: import_prop_types15.default.string,
  /**
   * Toolbar date format.
   */
  toolbarFormat: import_prop_types15.default.string,
  /**
   * Toolbar value placeholder—it is displayed when the value is empty.
   * @default "––"
   */
  toolbarPlaceholder: import_prop_types15.default.node,
  toolbarVariant: import_prop_types15.default.oneOf(["desktop", "mobile"]),
  value: import_prop_types15.default.arrayOf(import_prop_types15.default.object).isRequired,
  /**
   * Currently visible picker view.
   */
  view: import_prop_types15.default.oneOf(["day", "hours", "meridiem", "minutes", "seconds"]).isRequired,
  /**
   * Available views.
   */
  views: import_prop_types15.default.arrayOf(import_prop_types15.default.oneOf(["day", "hours", "meridiem", "minutes", "seconds"]).isRequired).isRequired
} : void 0;

// node_modules/@mui/x-date-pickers-pro/DateTimeRangePicker/DateTimeRangePickerTabs.js
var React31 = __toESM(require_react());
init_clsx();
var import_prop_types16 = __toESM(require_prop_types());
init_composeClasses();
init_useEventCallback();

// node_modules/@mui/x-date-pickers-pro/DateTimeRangePicker/dateTimeRangePickerTabsClasses.js
init_generateUtilityClass();
init_generateUtilityClasses();
function getDateTimeRangePickerTabsUtilityClass(slot) {
  return generateUtilityClass("MuiDateTimeRangePickerTabs", slot);
}
var dateTimeRangePickerTabsClasses = generateUtilityClasses("MuiDateTimeRangePickerTabs", ["root", "tabButton", "navigationButton", "filler"]);

// node_modules/@mui/x-date-pickers-pro/DateTimeRangePicker/DateTimeRangePickerTabs.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var viewToTab = (view, rangePosition) => {
  if (isDatePickerView(view)) {
    return rangePosition === "start" ? "start-date" : "end-date";
  }
  return rangePosition === "start" ? "start-time" : "end-time";
};
var tabToView = (tab) => {
  if (tab === "start-date" || tab === "end-date") {
    return "day";
  }
  return "hours";
};
var useUtilityClasses8 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    tabButton: ["tabButton"],
    navigationButton: ["navigationButton"],
    filler: ["filler"]
  };
  return composeClasses(slots, getDateTimeRangePickerTabsUtilityClass, classes);
};
var DateTimeRangePickerTabsRoot = styled_default("div", {
  name: "MuiDateTimeRangePickerTabs",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  theme
}) => ({
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
  minHeight: 48
}));
var DateTimeRangePickerTab = styled_default(Button_default, {
  name: "MuiDateTimeRangePickerTabs",
  slot: "TabButton",
  overridesResolver: (_, styles) => styles.tabButton
})({
  textTransform: "none"
});
var DateTimeRangePickerTabFiller = styled_default("div", {
  name: "MuiDateTimeRangePickerTabs",
  slot: "Filler",
  overridesResolver: (_, styles) => styles.filler
})({
  width: 40
});
var tabOptions = ["start-date", "start-time", "end-date", "end-time"];
var DateTimeRangePickerTabs = function DateTimeRangePickerTabs2(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDateTimeRangePickerTabs"
  });
  const {
    dateIcon = (0, import_jsx_runtime19.jsx)(DateRangeIcon, {}),
    onViewChange,
    timeIcon = (0, import_jsx_runtime19.jsx)(TimeIcon, {}),
    view,
    hidden = typeof window === "undefined" || window.innerHeight < 667,
    rangePosition,
    onRangePositionChange,
    className,
    sx
  } = props;
  const translations = usePickersTranslations();
  const classes = useUtilityClasses8(props);
  const value = React31.useMemo(() => viewToTab(view, rangePosition), [view, rangePosition]);
  const isPreviousHidden = value === "start-date";
  const isNextHidden = value === "end-time";
  const tabLabel = React31.useMemo(() => {
    switch (value) {
      case "start-date":
        return translations.startDate;
      case "start-time":
        return translations.startTime;
      case "end-date":
        return translations.endDate;
      case "end-time":
        return translations.endTime;
      default:
        return "";
    }
  }, [translations.endDate, translations.endTime, translations.startDate, translations.startTime, value]);
  const handleRangePositionChange = useEventCallback_default((newTab) => {
    if (newTab.includes("start")) {
      onRangePositionChange("start");
    } else {
      onRangePositionChange("end");
    }
  });
  const changeToPreviousTab = useEventCallback_default(() => {
    const previousTab = tabOptions[tabOptions.indexOf(value) - 1];
    onViewChange(tabToView(previousTab));
    handleRangePositionChange(previousTab);
  });
  const changeToNextTab = useEventCallback_default(() => {
    const nextTab = tabOptions[tabOptions.indexOf(value) + 1];
    onViewChange(tabToView(nextTab));
    handleRangePositionChange(nextTab);
  });
  if (hidden) {
    return null;
  }
  return (0, import_jsx_runtime19.jsxs)(DateTimeRangePickerTabsRoot, {
    ownerState: props,
    className: clsx_default(classes.root, className),
    sx,
    children: [!isPreviousHidden ? (0, import_jsx_runtime19.jsx)(IconButton_default, {
      onClick: changeToPreviousTab,
      className: classes.navigationButton,
      title: translations.openPreviousView,
      children: (0, import_jsx_runtime19.jsx)(ArrowLeftIcon, {})
    }) : (0, import_jsx_runtime19.jsx)(DateTimeRangePickerTabFiller, {
      className: classes.filler
    }), (0, import_jsx_runtime19.jsx)(DateTimeRangePickerTab, {
      startIcon: isDatePickerView(view) ? dateIcon : timeIcon,
      className: classes.tabButton,
      size: "large",
      children: tabLabel
    }), !isNextHidden ? (0, import_jsx_runtime19.jsx)(IconButton_default, {
      onClick: changeToNextTab,
      className: classes.navigationButton,
      title: translations.openNextView,
      children: (0, import_jsx_runtime19.jsx)(ArrowRightIcon, {})
    }) : (0, import_jsx_runtime19.jsx)(DateTimeRangePickerTabFiller, {
      className: classes.filler
    })]
  });
};
true ? DateTimeRangePickerTabs.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types16.default.object,
  className: import_prop_types16.default.string,
  /**
   * Date tab icon.
   * @default DateRangeIcon
   */
  dateIcon: import_prop_types16.default.element,
  /**
   * Toggles visibility of the tabs allowing view switching.
   * @default `window.innerHeight < 667` for `DesktopDateTimeRangePicker` and `MobileDateTimeRangePicker`
   */
  hidden: import_prop_types16.default.bool,
  onRangePositionChange: import_prop_types16.default.func.isRequired,
  /**
   * Callback called when a tab is clicked.
   * @template TView
   * @param {TView} view The view to open
   */
  onViewChange: import_prop_types16.default.func.isRequired,
  rangePosition: import_prop_types16.default.oneOf(["end", "start"]).isRequired,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types16.default.oneOfType([import_prop_types16.default.arrayOf(import_prop_types16.default.oneOfType([import_prop_types16.default.func, import_prop_types16.default.object, import_prop_types16.default.bool])), import_prop_types16.default.func, import_prop_types16.default.object]),
  /**
   * Time tab icon.
   * @default TimeIcon
   */
  timeIcon: import_prop_types16.default.element,
  /**
   * Currently visible picker view.
   */
  view: import_prop_types16.default.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]).isRequired
} : void 0;

// node_modules/@mui/x-date-pickers-pro/DateTimeRangePicker/shared.js
function useDateTimeRangePickerDefaultizedProps(props, name) {
  var _a;
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const themeProps = useThemeProps({
    props,
    name
  });
  const ampm = themeProps.ampm ?? utils.is12HourCycleInCurrentLocale();
  const {
    openTo,
    views: defaultViews
  } = applyDefaultViewProps({
    views: themeProps.views,
    openTo: themeProps.openTo,
    defaultViews: ["day", "hours", "minutes"],
    defaultOpenTo: "day"
  });
  const {
    shouldRenderTimeInASingleColumn,
    thresholdToRenderTimeInASingleColumn,
    views,
    timeSteps
  } = resolveTimeViewsResponse({
    thresholdToRenderTimeInASingleColumn: themeProps.thresholdToRenderTimeInASingleColumn,
    ampm,
    timeSteps: themeProps.timeSteps,
    views: defaultViews
  });
  return _extends({}, themeProps, {
    timeSteps,
    openTo,
    shouldRenderTimeInASingleColumn,
    thresholdToRenderTimeInASingleColumn,
    views,
    ampm,
    disableFuture: themeProps.disableFuture ?? false,
    disablePast: themeProps.disablePast ?? false,
    minDate: applyDefaultDate(utils, themeProps.minDateTime ?? themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils, themeProps.maxDateTime ?? themeProps.maxDate, defaultDates.maxDate),
    minTime: themeProps.minDateTime ?? themeProps.minTime,
    maxTime: themeProps.maxDateTime ?? themeProps.maxTime,
    disableIgnoringDatePartForTimeValidation: themeProps.disableIgnoringDatePartForTimeValidation ?? Boolean(themeProps.minDateTime || themeProps.maxDateTime || // allow digital clocks to correctly check time validity: https://github.com/mui/mui-x/issues/12048
    themeProps.disablePast || themeProps.disableFuture),
    slots: _extends({
      tabs: DateTimeRangePickerTabs,
      toolbar: DateTimeRangePickerToolbar
    }, themeProps.slots),
    slotProps: _extends({}, themeProps.slotProps, {
      toolbar: _extends({}, (_a = themeProps.slotProps) == null ? void 0 : _a.toolbar, {
        ampm
      })
    })
  });
}

// node_modules/@mui/x-date-pickers-pro/DateTimeRangePicker/DateTimeRangePickerTimeWrapper.js
init_extends();
init_objectWithoutPropertiesLoose();
var _excluded20 = ["rangePosition", "onRangePositionChange", "viewRenderer", "value", "onChange", "defaultValue", "onViewChange", "views", "className"];
function DateTimeRangePickerTimeWrapper(props, ref) {
  const utils = useUtils();
  const {
    rangePosition,
    onRangePositionChange,
    viewRenderer,
    value,
    onChange,
    defaultValue,
    onViewChange,
    views
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded20);
  if (!viewRenderer) {
    return null;
  }
  const currentValue = (rangePosition === "start" ? value == null ? void 0 : value[0] : value == null ? void 0 : value[1]) ?? null;
  const currentDefaultValue = (rangePosition === "start" ? defaultValue == null ? void 0 : defaultValue[0] : defaultValue == null ? void 0 : defaultValue[1]) ?? null;
  const handleOnChange = (newDate, selectionState, selectedView) => {
    if (!onChange || !value) {
      return;
    }
    const {
      newRange
    } = calculateRangeChange({
      newDate,
      utils,
      range: value,
      rangePosition
    });
    const isFullRangeSelected = rangePosition === "end" && isRangeValid(utils, newRange);
    const timeViews = views.filter(isInternalTimeView);
    if (selectedView === timeViews[timeViews.length - 1] && onViewChange) {
      onViewChange(views[0]);
      onRangePositionChange(rangePosition === "start" ? "end" : "start");
    }
    onChange(newRange, isFullRangeSelected ? "finish" : "partial", selectedView);
  };
  return viewRenderer(_extends({}, other, {
    ref,
    views,
    onViewChange,
    value: currentValue,
    onChange: handleOnChange,
    defaultValue: currentDefaultValue
  }));
}

// node_modules/@mui/x-date-pickers-pro/DesktopDateTimeRangePicker/DesktopDateTimeRangePicker.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var _excluded21 = ["openTo", "rangePosition"];
var rendererInterceptor = function rendererInterceptor2(inViewRenderers, popperView, rendererProps) {
  var _a;
  const {
    openTo,
    rangePosition
  } = rendererProps, otherProps = _objectWithoutPropertiesLoose(rendererProps, _excluded21);
  const finalProps = _extends({}, otherProps, {
    rangePosition,
    focusedView: null,
    sx: [{
      [`&.${multiSectionDigitalClockClasses.root}`]: {
        borderBottom: 0
      },
      [`&.${multiSectionDigitalClockClasses.root}, .${multiSectionDigitalClockSectionClasses.root}, &.${digitalClockClasses.root}`]: {
        maxHeight: RANGE_VIEW_HEIGHT
      }
    }]
  });
  const isTimeViewActive = isInternalTimeView(popperView);
  return (0, import_jsx_runtime20.jsxs)(React32.Fragment, {
    children: [(_a = inViewRenderers.day) == null ? void 0 : _a.call(inViewRenderers, _extends({}, rendererProps, {
      availableRangePositions: [rangePosition],
      view: !isTimeViewActive ? popperView : "day",
      views: rendererProps.views.filter(isDatePickerView),
      sx: [{
        gridColumn: 1
      }, ...finalProps.sx]
    })), (0, import_jsx_runtime20.jsx)(Divider_default, {
      orientation: "vertical",
      sx: {
        gridColumn: 2
      }
    }), (0, import_jsx_runtime20.jsx)(DateTimeRangePickerTimeWrapper, _extends({}, finalProps, {
      view: isTimeViewActive ? popperView : "hours",
      views: finalProps.views.filter(isInternalTimeView),
      openTo: isInternalTimeView(openTo) ? openTo : "hours",
      viewRenderer: inViewRenderers[isTimeViewActive ? popperView : "hours"],
      sx: [{
        gridColumn: 3
      }, ...finalProps.sx]
    }))]
  });
};
var DesktopDateTimeRangePicker = React32.forwardRef(function DesktopDateTimeRangePicker2(inProps, ref) {
  var _a, _b, _c;
  const utils = useUtils();
  const defaultizedProps = useDateTimeRangePickerDefaultizedProps(inProps, "MuiDesktopDateTimeRangePicker");
  const renderTimeView = defaultizedProps.shouldRenderTimeInASingleColumn ? renderDigitalClockTimeView : renderMultiSectionDigitalClockTimeView;
  const viewRenderers = _extends({
    day: renderDateRangeViewCalendar,
    hours: renderTimeView,
    minutes: renderTimeView,
    seconds: renderTimeView,
    meridiem: renderTimeView
  }, defaultizedProps.viewRenderers);
  const shouldHoursRendererContainMeridiemView = ((_a = viewRenderers.hours) == null ? void 0 : _a.name) === renderMultiSectionDigitalClockTimeView.name;
  const views = !shouldHoursRendererContainMeridiemView ? defaultizedProps.views.filter((view) => view !== "meridiem") : defaultizedProps.views;
  const actionBarActions = defaultizedProps.shouldRenderTimeInASingleColumn ? [] : ["accept"];
  const props = _extends({}, defaultizedProps, {
    views,
    viewRenderers,
    format: resolveDateTimeFormat(utils, defaultizedProps),
    // force true to correctly handle `renderTimeViewClock` as a renderer
    ampmInClock: true,
    calendars: defaultizedProps.calendars ?? 1,
    slots: _extends({
      field: MultiInputDateTimeRangeField,
      layout: DesktopDateTimePickerLayout
    }, defaultizedProps.slots),
    slotProps: _extends({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _a2;
        return _extends({}, resolveComponentProps_default((_a2 = defaultizedProps.slotProps) == null ? void 0 : _a2.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      tabs: _extends({
        hidden: true
      }, (_b = defaultizedProps.slotProps) == null ? void 0 : _b.tabs),
      toolbar: _extends({
        hidden: true,
        toolbarVariant: "desktop"
      }, (_c = defaultizedProps.slotProps) == null ? void 0 : _c.toolbar),
      actionBar: (ownerState) => {
        var _a2;
        return _extends({
          actions: actionBarActions
        }, resolveComponentProps_default((_a2 = defaultizedProps.slotProps) == null ? void 0 : _a2.actionBar, ownerState));
      }
    })
  });
  const {
    renderPicker
  } = useDesktopRangePicker({
    props,
    valueManager: rangeValueManager,
    valueType: "date-time",
    validator: validateDateTimeRange,
    rendererInterceptor
  });
  return renderPicker();
});
DesktopDateTimeRangePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default utils.is12HourCycleInCurrentLocale()
   */
  ampm: import_prop_types17.default.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types17.default.bool,
  /**
   * The number of calendars to render on **desktop**.
   * @default 1
   */
  calendars: import_prop_types17.default.oneOf([1, 2, 3]),
  className: import_prop_types17.default.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: import_prop_types17.default.bool,
  /**
   * Position the current month is rendered in.
   * @default 1
   */
  currentMonthCalendarPosition: import_prop_types17.default.oneOf([1, 2, 3]),
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: import_prop_types17.default.func,
  /**
   * The initial position in the edited date range.
   * Used when the component is not controlled.
   * @default 'start'
   */
  defaultRangePosition: import_prop_types17.default.oneOf(["end", "start"]),
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types17.default.arrayOf(import_prop_types17.default.object),
  /**
   * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
   * @default false
   */
  disableAutoMonthSwitching: import_prop_types17.default.bool,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types17.default.bool,
  /**
   * If `true`, editing dates by dragging is disabled.
   * @default false
   */
  disableDragEditing: import_prop_types17.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types17.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types17.default.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: import_prop_types17.default.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: import_prop_types17.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types17.default.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: import_prop_types17.default.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: import_prop_types17.default.any,
  /**
   * The day view will show as many weeks as needed after the end of the current month to match this value.
   * Put it to 6 to have a fixed number of weeks in Gregorian calendars
   */
  fixedWeekNumber: import_prop_types17.default.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: import_prop_types17.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types17.default.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   * Ignored if the field has several inputs.
   */
  inputRef: refType_default,
  /**
   * The label content.
   * Ignored if the field has several inputs.
   */
  label: import_prop_types17.default.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: import_prop_types17.default.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: import_prop_types17.default.object,
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: import_prop_types17.default.object,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: import_prop_types17.default.object,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: import_prop_types17.default.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: import_prop_types17.default.object,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: import_prop_types17.default.object,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: import_prop_types17.default.object,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: import_prop_types17.default.number,
  /**
   * Name attribute used by the `input` element in the Field.
   * Ignored if the field has several inputs.
   */
  name: import_prop_types17.default.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onAccept: import_prop_types17.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types17.default.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: import_prop_types17.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types17.default.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: import_prop_types17.default.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: import_prop_types17.default.func,
  /**
   * Callback fired when the range position changes.
   * @param {RangePosition} rangePosition The new range position.
   */
  onRangePositionChange: import_prop_types17.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types17.default.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: import_prop_types17.default.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: import_prop_types17.default.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: import_prop_types17.default.oneOf(["day", "hours", "minutes", "seconds"]),
  /**
   * The position in the currently edited date range.
   * Used when the component position is controlled.
   */
  rangePosition: import_prop_types17.default.oneOf(["end", "start"]),
  readOnly: import_prop_types17.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types17.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: import_prop_types17.default.object,
  /**
   * Component rendered on the "day" view when `props.loading` is true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => "..."
   */
  renderLoading: import_prop_types17.default.func,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types17.default.oneOfType([import_prop_types17.default.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types17.default.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types17.default.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: import_prop_types17.default.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types17.default.bool,
  /**
   * If `true`, disabled digital clock items will not be rendered.
   * @default false
   */
  skipDisabled: import_prop_types17.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types17.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types17.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types17.default.oneOfType([import_prop_types17.default.arrayOf(import_prop_types17.default.oneOfType([import_prop_types17.default.func, import_prop_types17.default.object, import_prop_types17.default.bool])), import_prop_types17.default.func, import_prop_types17.default.object]),
  /**
   * Amount of time options below or at which the single column time renderer is used.
   * @default 24
   */
  thresholdToRenderTimeInASingleColumn: import_prop_types17.default.number,
  /**
   * The time steps between two time unit options.
   * For example, if `timeStep.minutes = 8`, then the available minute options will be `[0, 8, 16, 24, 32, 40, 48, 56]`.
   * When single column time renderer is used, only `timeStep.minutes` will be used.
   * @default{ hours: 1, minutes: 5, seconds: 5 }
   */
  timeSteps: import_prop_types17.default.shape({
    hours: import_prop_types17.default.number,
    minutes: import_prop_types17.default.number,
    seconds: import_prop_types17.default.number
  }),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types17.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types17.default.arrayOf(import_prop_types17.default.object),
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: import_prop_types17.default.oneOf(["day", "hours", "meridiem", "minutes", "seconds"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be used.
   */
  viewRenderers: import_prop_types17.default.shape({
    day: import_prop_types17.default.func,
    hours: import_prop_types17.default.func,
    meridiem: import_prop_types17.default.func,
    minutes: import_prop_types17.default.func,
    seconds: import_prop_types17.default.func
  }),
  /**
   * Available views.
   */
  views: import_prop_types17.default.arrayOf(import_prop_types17.default.oneOf(["day", "hours", "minutes", "seconds"]).isRequired)
};

// node_modules/@mui/x-date-pickers-pro/MobileDateTimeRangePicker/MobileDateTimeRangePicker.js
init_extends();
init_objectWithoutPropertiesLoose();
var React33 = __toESM(require_react());
var import_prop_types18 = __toESM(require_prop_types());
init_esm();
init_resolveComponentProps();
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
var _excluded24 = ["view", "openTo", "rangePosition"];
var rendererInterceptor3 = function rendererInterceptor4(inViewRenderers, popperView, rendererProps) {
  const {
    view,
    openTo,
    rangePosition
  } = rendererProps, otherRendererProps = _objectWithoutPropertiesLoose(rendererProps, _excluded24);
  const finalProps = _extends({}, otherRendererProps, {
    rangePosition,
    focusedView: null,
    sx: [{
      width: DIALOG_WIDTH,
      [`.${multiSectionDigitalClockSectionClasses.root}`]: {
        flex: 1,
        // account for the border on `MultiSectionDigitalClock`
        maxHeight: VIEW_HEIGHT - 1,
        [`.${multiSectionDigitalClockSectionClasses.item}`]: {
          width: "auto"
        }
      },
      [`&.${digitalClockClasses.root}`]: {
        maxHeight: RANGE_VIEW_HEIGHT,
        [`.${digitalClockClasses.item}`]: {
          justifyContent: "center"
        }
      },
      [`&.${multiSectionDigitalClockClasses.root}, .${multiSectionDigitalClockSectionClasses.root}`]: {
        maxHeight: RANGE_VIEW_HEIGHT - 1
      }
    }]
  });
  const isTimeView2 = isInternalTimeView(popperView);
  const viewRenderer = inViewRenderers[popperView];
  if (!viewRenderer) {
    return null;
  }
  if (isTimeView2) {
    return (0, import_jsx_runtime21.jsx)(DateTimeRangePickerTimeWrapper, _extends({}, finalProps, {
      viewRenderer,
      view: view && isInternalTimeView(view) ? view : "hours",
      views: finalProps.views,
      openTo: isInternalTimeView(openTo) ? openTo : "hours"
    }));
  }
  const typedViewRenderer = viewRenderer;
  return typedViewRenderer(_extends({}, finalProps, {
    availableRangePositions: [rangePosition],
    views: finalProps.views.filter(isDatePickerView),
    view: view && isDatePickerView(view) ? view : "day",
    openTo: isDatePickerView(openTo) ? openTo : "day"
  }));
};
var MobileDateTimeRangePicker = React33.forwardRef(function MobileDateTimeRangePicker2(inProps, ref) {
  var _a, _b;
  const utils = useUtils();
  const defaultizedProps = useDateTimeRangePickerDefaultizedProps(inProps, "MuiMobileDateTimeRangePicker");
  const renderTimeView = defaultizedProps.shouldRenderTimeInASingleColumn ? renderDigitalClockTimeView : renderMultiSectionDigitalClockTimeView;
  const viewRenderers = _extends({
    day: renderDateRangeViewCalendar,
    hours: renderTimeView,
    minutes: renderTimeView,
    seconds: renderTimeView,
    meridiem: renderTimeView
  }, defaultizedProps.viewRenderers);
  const props = _extends({}, defaultizedProps, {
    viewRenderers,
    format: resolveDateTimeFormat(utils, defaultizedProps),
    // Force one calendar on mobile to avoid layout issues
    calendars: 1,
    // force true to correctly handle `renderTimeViewClock` as a renderer
    ampmInClock: true,
    slots: _extends({
      field: MultiInputDateTimeRangeField
    }, defaultizedProps.slots),
    slotProps: _extends({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _a2;
        return _extends({}, resolveComponentProps_default((_a2 = defaultizedProps.slotProps) == null ? void 0 : _a2.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      tabs: _extends({
        hidden: false
      }, (_a = defaultizedProps.slotProps) == null ? void 0 : _a.tabs),
      toolbar: _extends({
        hidden: false,
        toolbarVariant: "mobile"
      }, (_b = defaultizedProps.slotProps) == null ? void 0 : _b.toolbar)
    })
  });
  const {
    renderPicker
  } = useMobileRangePicker({
    props,
    valueManager: rangeValueManager,
    valueType: "date-time",
    validator: validateDateTimeRange,
    rendererInterceptor: rendererInterceptor3
  });
  return renderPicker();
});
MobileDateTimeRangePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default utils.is12HourCycleInCurrentLocale()
   */
  ampm: import_prop_types18.default.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types18.default.bool,
  className: import_prop_types18.default.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: import_prop_types18.default.bool,
  /**
   * Position the current month is rendered in.
   * @default 1
   */
  currentMonthCalendarPosition: import_prop_types18.default.oneOf([1, 2, 3]),
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: import_prop_types18.default.func,
  /**
   * The initial position in the edited date range.
   * Used when the component is not controlled.
   * @default 'start'
   */
  defaultRangePosition: import_prop_types18.default.oneOf(["end", "start"]),
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types18.default.arrayOf(import_prop_types18.default.object),
  /**
   * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
   * @default false
   */
  disableAutoMonthSwitching: import_prop_types18.default.bool,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types18.default.bool,
  /**
   * If `true`, editing dates by dragging is disabled.
   * @default false
   */
  disableDragEditing: import_prop_types18.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types18.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types18.default.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: import_prop_types18.default.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: import_prop_types18.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types18.default.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: import_prop_types18.default.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: import_prop_types18.default.any,
  /**
   * The day view will show as many weeks as needed after the end of the current month to match this value.
   * Put it to 6 to have a fixed number of weeks in Gregorian calendars
   */
  fixedWeekNumber: import_prop_types18.default.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: import_prop_types18.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types18.default.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   * Ignored if the field has several inputs.
   */
  inputRef: refType_default,
  /**
   * The label content.
   * Ignored if the field has several inputs.
   */
  label: import_prop_types18.default.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: import_prop_types18.default.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: import_prop_types18.default.object,
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: import_prop_types18.default.object,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: import_prop_types18.default.object,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: import_prop_types18.default.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: import_prop_types18.default.object,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: import_prop_types18.default.object,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: import_prop_types18.default.object,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: import_prop_types18.default.number,
  /**
   * Name attribute used by the `input` element in the Field.
   * Ignored if the field has several inputs.
   */
  name: import_prop_types18.default.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onAccept: import_prop_types18.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types18.default.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: import_prop_types18.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types18.default.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: import_prop_types18.default.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: import_prop_types18.default.func,
  /**
   * Callback fired when the range position changes.
   * @param {RangePosition} rangePosition The new range position.
   */
  onRangePositionChange: import_prop_types18.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types18.default.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: import_prop_types18.default.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: import_prop_types18.default.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: import_prop_types18.default.oneOf(["day", "hours", "minutes", "seconds"]),
  /**
   * The position in the currently edited date range.
   * Used when the component position is controlled.
   */
  rangePosition: import_prop_types18.default.oneOf(["end", "start"]),
  readOnly: import_prop_types18.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types18.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: import_prop_types18.default.object,
  /**
   * Component rendered on the "day" view when `props.loading` is true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => "..."
   */
  renderLoading: import_prop_types18.default.func,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types18.default.oneOfType([import_prop_types18.default.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types18.default.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types18.default.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: import_prop_types18.default.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types18.default.bool,
  /**
   * If `true`, disabled digital clock items will not be rendered.
   * @default false
   */
  skipDisabled: import_prop_types18.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types18.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types18.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types18.default.oneOfType([import_prop_types18.default.arrayOf(import_prop_types18.default.oneOfType([import_prop_types18.default.func, import_prop_types18.default.object, import_prop_types18.default.bool])), import_prop_types18.default.func, import_prop_types18.default.object]),
  /**
   * Amount of time options below or at which the single column time renderer is used.
   * @default 24
   */
  thresholdToRenderTimeInASingleColumn: import_prop_types18.default.number,
  /**
   * The time steps between two time unit options.
   * For example, if `timeStep.minutes = 8`, then the available minute options will be `[0, 8, 16, 24, 32, 40, 48, 56]`.
   * When single column time renderer is used, only `timeStep.minutes` will be used.
   * @default{ hours: 1, minutes: 5, seconds: 5 }
   */
  timeSteps: import_prop_types18.default.shape({
    hours: import_prop_types18.default.number,
    minutes: import_prop_types18.default.number,
    seconds: import_prop_types18.default.number
  }),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types18.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types18.default.arrayOf(import_prop_types18.default.object),
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: import_prop_types18.default.oneOf(["day", "hours", "meridiem", "minutes", "seconds"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be used.
   */
  viewRenderers: import_prop_types18.default.shape({
    day: import_prop_types18.default.func,
    hours: import_prop_types18.default.func,
    meridiem: import_prop_types18.default.func,
    minutes: import_prop_types18.default.func,
    seconds: import_prop_types18.default.func
  }),
  /**
   * Available views.
   */
  views: import_prop_types18.default.arrayOf(import_prop_types18.default.oneOf(["day", "hours", "minutes", "seconds"]).isRequired)
};

// node_modules/@mui/x-date-pickers-pro/DateTimeRangePicker/DateTimeRangePicker.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
var _excluded25 = ["desktopModeMediaQuery"];
var DateTimeRangePicker = React34.forwardRef(function DateTimeRangePicker2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDateTimeRangePicker"
  });
  const {
    desktopModeMediaQuery = "@media (pointer: fine)"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded25);
  const isDesktop = useMediaQuery(desktopModeMediaQuery, {
    defaultMatches: true
  });
  if (isDesktop) {
    return (0, import_jsx_runtime22.jsx)(DesktopDateTimeRangePicker, _extends({
      ref
    }, other));
  }
  return (0, import_jsx_runtime22.jsx)(MobileDateTimeRangePicker, _extends({
    ref
  }, other));
});
true ? DateTimeRangePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default utils.is12HourCycleInCurrentLocale()
   */
  ampm: import_prop_types19.default.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types19.default.bool,
  /**
   * The number of calendars to render on **desktop**.
   * @default 1
   */
  calendars: import_prop_types19.default.oneOf([1, 2, 3]),
  className: import_prop_types19.default.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: import_prop_types19.default.bool,
  /**
   * Position the current month is rendered in.
   * @default 1
   */
  currentMonthCalendarPosition: import_prop_types19.default.oneOf([1, 2, 3]),
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: import_prop_types19.default.func,
  /**
   * The initial position in the edited date range.
   * Used when the component is not controlled.
   * @default 'start'
   */
  defaultRangePosition: import_prop_types19.default.oneOf(["end", "start"]),
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types19.default.arrayOf(import_prop_types19.default.object),
  /**
   * CSS media query when `Mobile` mode will be changed to `Desktop`.
   * @default '@media (pointer: fine)'
   * @example '@media (min-width: 720px)' or theme.breakpoints.up("sm")
   */
  desktopModeMediaQuery: import_prop_types19.default.string,
  /**
   * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
   * @default false
   */
  disableAutoMonthSwitching: import_prop_types19.default.bool,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types19.default.bool,
  /**
   * If `true`, editing dates by dragging is disabled.
   * @default false
   */
  disableDragEditing: import_prop_types19.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types19.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types19.default.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: import_prop_types19.default.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: import_prop_types19.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types19.default.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: import_prop_types19.default.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: import_prop_types19.default.any,
  /**
   * The day view will show as many weeks as needed after the end of the current month to match this value.
   * Put it to 6 to have a fixed number of weeks in Gregorian calendars
   */
  fixedWeekNumber: import_prop_types19.default.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: import_prop_types19.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types19.default.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   * Ignored if the field has several inputs.
   */
  inputRef: refType_default,
  /**
   * The label content.
   * Ignored if the field has several inputs.
   */
  label: import_prop_types19.default.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: import_prop_types19.default.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: import_prop_types19.default.object,
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: import_prop_types19.default.object,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: import_prop_types19.default.object,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: import_prop_types19.default.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: import_prop_types19.default.object,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: import_prop_types19.default.object,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: import_prop_types19.default.object,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: import_prop_types19.default.number,
  /**
   * Name attribute used by the `input` element in the Field.
   * Ignored if the field has several inputs.
   */
  name: import_prop_types19.default.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onAccept: import_prop_types19.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types19.default.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: import_prop_types19.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types19.default.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: import_prop_types19.default.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: import_prop_types19.default.func,
  /**
   * Callback fired when the range position changes.
   * @param {RangePosition} rangePosition The new range position.
   */
  onRangePositionChange: import_prop_types19.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types19.default.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: import_prop_types19.default.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: import_prop_types19.default.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: import_prop_types19.default.oneOf(["day", "hours", "minutes", "seconds"]),
  /**
   * The position in the currently edited date range.
   * Used when the component position is controlled.
   */
  rangePosition: import_prop_types19.default.oneOf(["end", "start"]),
  readOnly: import_prop_types19.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types19.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: import_prop_types19.default.object,
  /**
   * Component rendered on the "day" view when `props.loading` is true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => "..."
   */
  renderLoading: import_prop_types19.default.func,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types19.default.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types19.default.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: import_prop_types19.default.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types19.default.bool,
  /**
   * If `true`, disabled digital clock items will not be rendered.
   * @default false
   */
  skipDisabled: import_prop_types19.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types19.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types19.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
  /**
   * Amount of time options below or at which the single column time renderer is used.
   * @default 24
   */
  thresholdToRenderTimeInASingleColumn: import_prop_types19.default.number,
  /**
   * The time steps between two time unit options.
   * For example, if `timeStep.minutes = 8`, then the available minute options will be `[0, 8, 16, 24, 32, 40, 48, 56]`.
   * When single column time renderer is used, only `timeStep.minutes` will be used.
   * @default{ hours: 1, minutes: 5, seconds: 5 }
   */
  timeSteps: import_prop_types19.default.shape({
    hours: import_prop_types19.default.number,
    minutes: import_prop_types19.default.number,
    seconds: import_prop_types19.default.number
  }),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types19.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types19.default.arrayOf(import_prop_types19.default.object),
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: import_prop_types19.default.oneOf(["day", "hours", "meridiem", "minutes", "seconds"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be used.
   */
  viewRenderers: import_prop_types19.default.shape({
    day: import_prop_types19.default.func,
    hours: import_prop_types19.default.func,
    meridiem: import_prop_types19.default.func,
    minutes: import_prop_types19.default.func,
    seconds: import_prop_types19.default.func
  }),
  /**
   * Available views.
   */
  views: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOf(["day", "hours", "minutes", "seconds"]).isRequired)
} : void 0;

// node_modules/@mui/x-date-pickers-pro/index.js
var LicenseInfo2 = class extends LicenseInfo {
};
export {
  ArrowDropDownIcon,
  ArrowLeftIcon,
  ArrowRightIcon,
  CalendarIcon,
  ClearIcon,
  ClockIcon,
  DEFAULT_DESKTOP_MODE_MEDIA_QUERY,
  DateCalendar,
  DateField,
  DatePicker,
  DatePickerToolbar,
  DateRangeCalendar,
  DateRangeIcon,
  DateRangePicker,
  DateRangePickerDay2 as DateRangePickerDay,
  DateRangePickerToolbar,
  DateTimeField,
  DateTimePicker,
  DateTimePickerTabs,
  DateTimePickerToolbar,
  DateTimeRangePicker,
  DateTimeRangePickerTabs,
  DateTimeRangePickerToolbar,
  DayCalendarSkeleton,
  DesktopDatePicker,
  DesktopDateRangePicker,
  DesktopDateTimePicker,
  DesktopDateTimePickerLayout,
  DesktopDateTimeRangePicker,
  DesktopTimePicker,
  DigitalClock,
  LicenseInfo2 as LicenseInfo,
  LocalizationProvider,
  MobileDatePicker,
  MobileDateRangePicker,
  MobileDateTimePicker,
  MobileDateTimeRangePicker,
  MobileTimePicker,
  MonthCalendar,
  MuiPickersAdapterContext,
  MultiInputDateRangeField,
  MultiInputDateTimeRangeField,
  MultiInputTimeRangeField,
  MultiSectionDigitalClock,
  PickersActionBar,
  PickersCalendarHeader,
  PickersDay,
  PickersFilledInput,
  PickersInput,
  PickersInputBase,
  PickersLayout,
  PickersLayoutContentWrapper,
  PickersLayoutRoot,
  PickersOutlinedInput,
  PickersRangeCalendarHeader,
  PickersShortcuts,
  PickersTextField,
  SingleInputDateRangeField,
  SingleInputDateTimeRangeField,
  SingleInputTimeRangeField,
  StaticDatePicker,
  StaticDateRangePicker,
  StaticDateTimePicker,
  StaticTimePicker,
  TimeClock,
  TimeField,
  TimeIcon,
  TimePicker,
  TimePickerToolbar,
  PickersSectionList as Unstable_PickersSectionList,
  PickersSectionListRoot as Unstable_PickersSectionListRoot,
  PickersSectionListSection as Unstable_PickersSectionListSection,
  PickersSectionListSectionContent as Unstable_PickersSectionListSectionContent,
  PickersSectionListSectionSeparator as Unstable_PickersSectionListSectionSeparator,
  YearCalendar,
  clockClasses,
  clockNumberClasses,
  clockPointerClasses,
  dateCalendarClasses,
  datePickerToolbarClasses,
  dateRangeCalendarClasses,
  dateRangePickerDayClasses,
  dateRangePickerToolbarClasses,
  dateTimePickerTabsClasses,
  dateTimePickerToolbarClasses,
  dateTimeRangePickerTabsClasses,
  dateTimeRangePickerToolbarClasses,
  dayCalendarClasses,
  dayCalendarSkeletonClasses,
  digitalClockClasses,
  getDateCalendarUtilityClass,
  getDateRangeCalendarUtilityClass,
  getDateRangePickerDayUtilityClass,
  getDateRangePickerToolbarUtilityClass,
  getDateTimeRangePickerTabsUtilityClass,
  getDateTimeRangePickerToolbarUtilityClass,
  getDayCalendarSkeletonUtilityClass,
  getDigitalClockUtilityClass,
  getMonthCalendarUtilityClass,
  getMultiInputDateRangeFieldUtilityClass,
  getMultiInputDateTimeRangeFieldUtilityClass,
  getMultiInputTimeRangeFieldUtilityClass,
  getMultiSectionDigitalClockUtilityClass,
  getPickersDayUtilityClass,
  getPickersFilledInputUtilityClass,
  getPickersInputBaseUtilityClass,
  getPickersInputUtilityClass,
  getPickersOutlinedInputUtilityClass,
  getPickersSectionListUtilityClass,
  getPickersTextFieldUtilityClass,
  getTimeClockUtilityClass,
  getYearCalendarUtilityClass,
  monthCalendarClasses,
  multiInputDateRangeFieldClasses,
  multiInputDateTimeRangeFieldClasses,
  multiInputTimeRangeFieldClasses,
  multiSectionDigitalClockClasses,
  multiSectionDigitalClockSectionClasses,
  pickersCalendarHeaderClasses,
  pickersDayClasses,
  pickersFadeTransitionGroupClasses,
  pickersFilledInputClasses,
  pickersInputBaseClasses,
  pickersInputClasses,
  pickersLayoutClasses,
  pickersMonthClasses,
  pickersOutlinedInputClasses,
  pickersSectionListClasses,
  pickersSlideTransitionClasses,
  pickersTextFieldClasses,
  pickersYearClasses,
  renderDateRangeViewCalendar,
  renderDateViewCalendar,
  renderDigitalClockTimeView,
  renderMultiSectionDigitalClockTimeView,
  renderTimeViewClock,
  timeClockClasses,
  timePickerToolbarClasses,
  useDateField as unstable_useDateField,
  useDateTimeField as unstable_useDateTimeField,
  useMultiInputDateRangeField as unstable_useMultiInputDateRangeField,
  useMultiInputDateTimeRangeField as unstable_useMultiInputDateTimeRangeField,
  useMultiInputTimeRangeField as unstable_useMultiInputTimeRangeField,
  useSingleInputDateRangeField as unstable_useSingleInputDateRangeField,
  useSingleInputDateTimeRangeField as unstable_useSingleInputDateTimeRangeField,
  useSingleInputTimeRangeField as unstable_useSingleInputTimeRangeField,
  useTimeField as unstable_useTimeField,
  useClearableField,
  usePickerLayout_default as usePickerLayout,
  usePickersTranslations,
  yearCalendarClasses
};
/*! Bundled license information:

@mui/x-license/index.js:
  (**
   * @mui/x-license v7.12.0
   *
   * @license MUI X Commercial
   * This source code is licensed under the commercial license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@mui/x-date-pickers-pro/index.js:
  (**
   * @mui/x-date-pickers-pro v7.12.1
   *
   * @license MUI X Commercial
   * This source code is licensed under the commercial license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@mui_x-date-pickers-pro.js.map
